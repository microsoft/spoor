#include "spoor/runtime/buffer/circular_slice_buffer.h"

#include "gtest/gtest.h"
#include "spoor/runtime/buffer/reserved_buffer_slice_pool.h"
#include "util/numeric.h"

namespace {

using SlicePool = spoor::runtime::buffer::BufferSlicePool<uint64>;

using CircularBuffer = spoor::runtime::buffer::CircularBuffer<int64>;
using ValueType = CircularBuffer::ValueType;
using SizeType = CircularBuffer::SizeType;
using CircularSliceBuffer =
    spoor::runtime::buffer::CircularSliceBuffer<ValueType>;
using Pool = spoor::runtime::buffer::ReservedBufferSlicePool<ValueType>;
using OwnedSlicePtr = util::memory::OwnedPtr<CircularBuffer>;

const SizeType kCapacity{10};

TEST(CircularSliceBuffer, ManualFlush) {  // NOLINT
}

TEST(CircularSliceBuffer, ManualFlush) {  // NOLINT
  const SizeType capacity{10};
  const typename Pool::Options options{.max_slice_capacity = 2,
                                       .capacity = capacity};
  Pool pool{options};
  auto flushed = false;
  const auto flush_handler =
      [&flushed](std::vector<OwnedSlicePtr>&& /*unused*/) { flushed = true; };
  const typename CircularSliceBuffer::Options circular_slice_buffer_options{
      .flush_handler = flush_handler,
      .buffer_slice_pool = &pool,
      .flush_when_full = false};
  CircularSliceBuffer circular_slice_buffer{circular_slice_buffer_options};
  for (SizeType size{1}; size < capacity + 1; ++size) {
    ASSERT_TRUE(circular_slice_buffer.Empty());
    flushed = false;
    for (SizeType i{0}; i < size; ++i) {
      circular_slice_buffer.Push(i);
      ASSERT_EQ(circular_slice_buffer.Size(), i + 1);
    }
    circular_slice_buffer.Flush();
    ASSERT_TRUE(flushed);
  }
}

TEST(CircularSliceBuffer, ContiguousMemoryChunks) {  // NOLINT
}

}  // namespace
