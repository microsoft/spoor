{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Spoor Spoor gives you deep insight into your application's performance. Its three-part toolchain enables you to analyze your application down to the function call with nanosecond precision and includes: Compiler instrumentation to auto-inject trace events. A runtime library to capture and buffer events. Tools to process and visualize the traces. Get started Project status Spoor is still in its infancy and should be considered alpha-quality software. Please anticipate breaking changes, report bugs that you encounter, and consider contributing code to support Spoor's development. Wikipedia's iOS app boot instrumented with Spoor and visualized with Perfetto.","title":"Home"},{"location":"#spoor","text":"Spoor gives you deep insight into your application's performance. Its three-part toolchain enables you to analyze your application down to the function call with nanosecond precision and includes: Compiler instrumentation to auto-inject trace events. A runtime library to capture and buffer events. Tools to process and visualize the traces. Get started Project status Spoor is still in its infancy and should be considered alpha-quality software. Please anticipate breaking changes, report bugs that you encounter, and consider contributing code to support Spoor's development. Wikipedia's iOS app boot instrumented with Spoor and visualized with Perfetto.","title":"Spoor"},{"location":"contributing/","text":"Contributing Thank you for your interest in Spoor. There are several ways to get involved in Spoor's development. Provide feedback Please report an issue on GitHub if you find something to improve. For example: Spoor crashes or you encounter a bug. The documentation is incomplete or unclear. An error message could be improved. Security Please do not report security vulnerabilities through public GitHub issues. Instead, report them to the Microsoft Security Response Center. Details . Contribute code All development happens on GitHub . Both core team members and external contributors submit pull requests which go through the same review process. The most helpful contributions fix bugs, improve performance, or add features (as opposed to stylistic or \"gardening\" changes). Test and document your work. When you're read to roll up your sleeves and start coding, check out the development setup guide. Style guide Follow Spoor's style guide when writing code. Contributor License Agreement Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit cla.opensource.microsoft.com . When you submit a pull request, the CLA bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA. Code of Conduct This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with questions or comments. Trademarks This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft trademarks or logos is subject to and must follow Microsoft\u2019s Trademark & Brand Guidelines . Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship. Any use of third-party trademarks or logos are subject to those third-party\u2019s policies.","title":"Overview"},{"location":"contributing/#contributing","text":"Thank you for your interest in Spoor. There are several ways to get involved in Spoor's development.","title":"Contributing"},{"location":"contributing/#provide-feedback","text":"Please report an issue on GitHub if you find something to improve. For example: Spoor crashes or you encounter a bug. The documentation is incomplete or unclear. An error message could be improved.","title":"Provide feedback"},{"location":"contributing/#security","text":"Please do not report security vulnerabilities through public GitHub issues. Instead, report them to the Microsoft Security Response Center. Details .","title":"Security"},{"location":"contributing/#contribute-code","text":"All development happens on GitHub . Both core team members and external contributors submit pull requests which go through the same review process. The most helpful contributions fix bugs, improve performance, or add features (as opposed to stylistic or \"gardening\" changes). Test and document your work. When you're read to roll up your sleeves and start coding, check out the development setup guide.","title":"Contribute code"},{"location":"contributing/#style-guide","text":"Follow Spoor's style guide when writing code.","title":"Style guide"},{"location":"contributing/#contributor-license-agreement","text":"Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit cla.opensource.microsoft.com . When you submit a pull request, the CLA bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.","title":"Contributor License Agreement"},{"location":"contributing/#code-of-conduct","text":"This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with questions or comments.","title":"Code of Conduct"},{"location":"contributing/#trademarks","text":"This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft trademarks or logos is subject to and must follow Microsoft\u2019s Trademark & Brand Guidelines . Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship. Any use of third-party trademarks or logos are subject to those third-party\u2019s policies.","title":"Trademarks"},{"location":"contributing/code-of-conduct/","text":"Microsoft Open Source Code of Conduct This project has adopted the Microsoft Open Source Code of Conduct . Resources Microsoft Open Source Code of Conduct Microsoft Code of Conduct FAQ Contact opencode@microsoft.com with questions or concerns","title":"Code of Conduct"},{"location":"contributing/code-of-conduct/#microsoft-open-source-code-of-conduct","text":"This project has adopted the Microsoft Open Source Code of Conduct .","title":"Microsoft Open Source Code of Conduct"},{"location":"contributing/code-of-conduct/#resources","text":"Microsoft Open Source Code of Conduct Microsoft Code of Conduct FAQ Contact opencode@microsoft.com with questions or concerns","title":"Resources"},{"location":"contributing/development-setup/","text":"Development Setup Requirements LLVM 13 including clang++ , opt , clang-format , clang-tidy , and libc++ . Python 3 , and Pylint and YAPF to format and lint code. Bazel build system. Material for MkDocs to generate documentation. Bazel configuration Check out the bazelrc files in the .build folder to help configure Spoor for your environment. Build bazel build //... Test bazel test //... Style and lint Format C++, Objective-C, and Python bazel build //... --aspects toolchain/style/style.bzl%format --output_groups = report Format Starlark bazel run //toolchain/style:buildifier Lint C++ and Python bazel build //... --aspects toolchain/style/style.bzl%lint --output_groups = report CI toolchain CI uses the LLVM toolchain when running the linter. --crosstool_top = //toolchain/crosstool:llvm_toolchain Add copyright header ./toolchain/copyright_header/add_copyright_header.sh Compilation database Generate a compile_commands.json compilation database used by Clang Tidy for linting and by some IDEs to offer code completion. Details . ./toolchain/compilation_database/generate_compilation_database.sh Documentation Build mkdocs build Live preview server mkdocs serve INFO - Building documentation... INFO - Cleaning site directory INFO - Documentation built in 0.80 seconds INFO - [00:00:00] Serving on http://127.0.0.1:8000/","title":"Development Setup"},{"location":"contributing/development-setup/#development-setup","text":"","title":"Development Setup"},{"location":"contributing/development-setup/#requirements","text":"LLVM 13 including clang++ , opt , clang-format , clang-tidy , and libc++ . Python 3 , and Pylint and YAPF to format and lint code. Bazel build system. Material for MkDocs to generate documentation. Bazel configuration Check out the bazelrc files in the .build folder to help configure Spoor for your environment.","title":"Requirements"},{"location":"contributing/development-setup/#build","text":"bazel build //...","title":"Build"},{"location":"contributing/development-setup/#test","text":"bazel test //...","title":"Test"},{"location":"contributing/development-setup/#style-and-lint","text":"","title":"Style and lint"},{"location":"contributing/development-setup/#format-c-objective-c-and-python","text":"bazel build //... --aspects toolchain/style/style.bzl%format --output_groups = report","title":"Format C++, Objective-C, and Python"},{"location":"contributing/development-setup/#format-starlark","text":"bazel run //toolchain/style:buildifier","title":"Format Starlark"},{"location":"contributing/development-setup/#lint-c-and-python","text":"bazel build //... --aspects toolchain/style/style.bzl%lint --output_groups = report CI toolchain CI uses the LLVM toolchain when running the linter. --crosstool_top = //toolchain/crosstool:llvm_toolchain","title":"Lint C++ and Python"},{"location":"contributing/development-setup/#add-copyright-header","text":"./toolchain/copyright_header/add_copyright_header.sh","title":"Add copyright header"},{"location":"contributing/development-setup/#compilation-database","text":"Generate a compile_commands.json compilation database used by Clang Tidy for linting and by some IDEs to offer code completion. Details . ./toolchain/compilation_database/generate_compilation_database.sh","title":"Compilation database"},{"location":"contributing/development-setup/#documentation","text":"","title":"Documentation"},{"location":"contributing/development-setup/#build_1","text":"mkdocs build","title":"Build"},{"location":"contributing/development-setup/#live-preview-server","text":"mkdocs serve INFO - Building documentation... INFO - Cleaning site directory INFO - Documentation built in 0.80 seconds INFO - [00:00:00] Serving on http://127.0.0.1:8000/","title":"Live preview server"},{"location":"contributing/license/","text":"Spoor Copyright (c) Microsoft Corporation. MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED AS IS , WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"contributing/security/","text":"Security Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include Microsoft , Azure , DotNet , AspNet , Xamarin , and our GitHub organizations . If you believe you have found a security vulnerability in any Microsoft-owned repository that meets Microsoft's definition of a security vulnerability , please report it to us as described below. Reporting Security Issues Please do not report security vulnerabilities through public GitHub issues. Instead, please report them to the Microsoft Security Response Center (MSRC) at msrc.microsoft.com/create-report . If you prefer to submit without logging in, send email to secure@microsoft.com . If possible, encrypt your message with our PGP key; please download it from the Microsoft Security Response Center PGP Key page . You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at microsoft.com/msrc . Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue: Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.) Full paths of source file(s) related to the manifestation of the issue The location of the affected source code (tag/branch/commit or direct URL) Any special configuration required to reproduce the issue Step-by-step instructions to reproduce the issue Proof-of-concept or exploit code (if possible) Impact of the issue, including how an attacker might exploit the issue This information will help us triage your report more quickly. If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our Microsoft Bug Bounty Program page for more details about our active programs. Preferred Languages We prefer all communications to be in English. Policy Microsoft follows the principle of Coordinated Vulnerability Disclosure .","title":"Security"},{"location":"contributing/security/#security","text":"Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include Microsoft , Azure , DotNet , AspNet , Xamarin , and our GitHub organizations . If you believe you have found a security vulnerability in any Microsoft-owned repository that meets Microsoft's definition of a security vulnerability , please report it to us as described below.","title":"Security"},{"location":"contributing/security/#reporting-security-issues","text":"Please do not report security vulnerabilities through public GitHub issues. Instead, please report them to the Microsoft Security Response Center (MSRC) at msrc.microsoft.com/create-report . If you prefer to submit without logging in, send email to secure@microsoft.com . If possible, encrypt your message with our PGP key; please download it from the Microsoft Security Response Center PGP Key page . You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at microsoft.com/msrc . Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue: Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.) Full paths of source file(s) related to the manifestation of the issue The location of the affected source code (tag/branch/commit or direct URL) Any special configuration required to reproduce the issue Step-by-step instructions to reproduce the issue Proof-of-concept or exploit code (if possible) Impact of the issue, including how an attacker might exploit the issue This information will help us triage your report more quickly. If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our Microsoft Bug Bounty Program page for more details about our active programs.","title":"Reporting Security Issues"},{"location":"contributing/security/#preferred-languages","text":"We prefer all communications to be in English.","title":"Preferred Languages"},{"location":"contributing/security/#policy","text":"Microsoft follows the principle of Coordinated Vulnerability Disclosure .","title":"Policy"},{"location":"contributing/style-guide/","text":"Style Guide General Comments Use code comments sparingly. Comments should explain why a decision was made, not what the code is doing. Comments should be complete English sentences including the necessary articles (\"a\", \"an\", and \"the\") and punctuation, and should follow Microsoft's Writing Style Guide . Inequality operators Prefer using the < <=> or operators over <= , > , and >= . C++ Follow Google's C++ Style Guide . Function declarations Exception: Use trailing return types for all function, method, and labmda declarations. Functions and methods may not use automatic return type inference. // \u2705 Do this auto Add ( const int64 a , const int64 b ) -> int64 ; // \u274c Not this int64 Add ( const int64 a , const int64 b ); Header guard Exception: Use #pragma once instead of #define guard for header files. This project's tooling does not support automatically enforcing the header guard convention where the #define guard's identifier mirrors the file's path to guarantee uniqueness. Despite being non-standard, #pragma once carries advantages such as reducing the maintenance burden when renaming and moving files improves compilation speed in some cases. // \u2705 Do this #pragma once // \u274c Not this #ifndef SPOOR_PATH_TO_HEADER_H_ #define SPOOR_PATH_TO_HEADER_H_ ... #endif Initialization Prefer list (curly brace) initialization over other forms. List initialization does not allow type narrowing making it safer than its alternatives. MyClass :: MyClass ( const int64 value ) : value_ { value } {...} const int64 x { 42 }; const MyClass my_class { x }; Error handling Do not use C++ exceptions for error handling. In fact, Spoor disables exceptions by compiling with -fno-exceptions . Instead, handle errors with Spoor's Result<Value, Error> type used to return either a value on success or an error otherwise. Numeric values Use numeric types with a defined size. For convenience, integer types without the _t postifx are defined in util/numeric.h . Prefer using these typedef s over the values defined in <cstdint> . // \u2705 Do this #include \"util/numerics.h\" int64 x { 42 }; // \u274c Not this #include <cstdint> int x { 42 }; int64_t y { 7 }; Tools Use Clang Format and Clang Tidy to style and lint code. Ignore lint warnings In special circumstances it might make sense to ignore lint warnings, for example, when using an external library macro where the lint warning is unavoidable. Explicitly list the lint rules to ignore instead of using a blanket NOLINT or NOLINTNEXTLINE . // \u2705 Do this int64 a [] = { 1 , 2 , 3 }; // NOLINT(modernize-avoid-c-arrays) // \u274c Not this int64 a [] = { 1 , 2 , 3 }; // NOLINT Exception: Google Test and Abseil flags library macros. // \u2705 Okay TEST ( Foo , Bar ) { // NOLINT ... } // \u2705 Okay ABSL_FLAG ( // NOLINT std :: string , my_flag , {}, \"Description...\" ); Objective-C Follow Google's Objective-C Style Guide . Nil checks Exception: Do not use implicit nil checks // \u2705 Do this if ( a != nil ) // \u274c Not this if ( a ) Python Follow Google's Python Style Guide . Indentation Exception: Indent code with two spaces. Starlark (Bazel) Follow Starlark's Style Guide . Use Buildifier to style and lint Starlark files. Shell Follow Google's Shell Style Guide . Shebang Exception: Use the shebang #!/usr/bin/env bash which is more portable. # \u2705 Do this #!/usr/bin/env bash # \u274c Not this #!/bin/bash Markdown Follow Google's Markdown Style Guide . Character line limit Each line should be at most 80 characters long. Exception: URLs and tables which cannot be wrapped. Links Use reference-style links for long URLs. Use kebab-case for reference names, place references at the end of the file, and alphabetize the list. \u2705 Do this Follow [ Google's Markdown Style Guide ][ google-markdown-style-guide ]. [ google-markdown-style-guide ]: https://google.github.io/styleguide/docguide/style.html#document-layout \u274c Not this Follow [ Google's Markdown Style Guide ]( https://google.github.io/styleguide/docguide/style.html#document-layout ).","title":"Style Guide"},{"location":"contributing/style-guide/#style-guide","text":"","title":"Style Guide"},{"location":"contributing/style-guide/#general","text":"","title":"General"},{"location":"contributing/style-guide/#comments","text":"Use code comments sparingly. Comments should explain why a decision was made, not what the code is doing. Comments should be complete English sentences including the necessary articles (\"a\", \"an\", and \"the\") and punctuation, and should follow Microsoft's Writing Style Guide .","title":"Comments"},{"location":"contributing/style-guide/#inequality-operators","text":"Prefer using the < <=> or operators over <= , > , and >= .","title":"Inequality operators"},{"location":"contributing/style-guide/#c","text":"Follow Google's C++ Style Guide .","title":"C++"},{"location":"contributing/style-guide/#function-declarations","text":"Exception: Use trailing return types for all function, method, and labmda declarations. Functions and methods may not use automatic return type inference. // \u2705 Do this auto Add ( const int64 a , const int64 b ) -> int64 ; // \u274c Not this int64 Add ( const int64 a , const int64 b );","title":"Function declarations"},{"location":"contributing/style-guide/#header-guard","text":"Exception: Use #pragma once instead of #define guard for header files. This project's tooling does not support automatically enforcing the header guard convention where the #define guard's identifier mirrors the file's path to guarantee uniqueness. Despite being non-standard, #pragma once carries advantages such as reducing the maintenance burden when renaming and moving files improves compilation speed in some cases. // \u2705 Do this #pragma once // \u274c Not this #ifndef SPOOR_PATH_TO_HEADER_H_ #define SPOOR_PATH_TO_HEADER_H_ ... #endif","title":"Header guard"},{"location":"contributing/style-guide/#initialization","text":"Prefer list (curly brace) initialization over other forms. List initialization does not allow type narrowing making it safer than its alternatives. MyClass :: MyClass ( const int64 value ) : value_ { value } {...} const int64 x { 42 }; const MyClass my_class { x };","title":"Initialization"},{"location":"contributing/style-guide/#error-handling","text":"Do not use C++ exceptions for error handling. In fact, Spoor disables exceptions by compiling with -fno-exceptions . Instead, handle errors with Spoor's Result<Value, Error> type used to return either a value on success or an error otherwise.","title":"Error handling"},{"location":"contributing/style-guide/#numeric-values","text":"Use numeric types with a defined size. For convenience, integer types without the _t postifx are defined in util/numeric.h . Prefer using these typedef s over the values defined in <cstdint> . // \u2705 Do this #include \"util/numerics.h\" int64 x { 42 }; // \u274c Not this #include <cstdint> int x { 42 }; int64_t y { 7 };","title":"Numeric values"},{"location":"contributing/style-guide/#tools","text":"Use Clang Format and Clang Tidy to style and lint code.","title":"Tools"},{"location":"contributing/style-guide/#ignore-lint-warnings","text":"In special circumstances it might make sense to ignore lint warnings, for example, when using an external library macro where the lint warning is unavoidable. Explicitly list the lint rules to ignore instead of using a blanket NOLINT or NOLINTNEXTLINE . // \u2705 Do this int64 a [] = { 1 , 2 , 3 }; // NOLINT(modernize-avoid-c-arrays) // \u274c Not this int64 a [] = { 1 , 2 , 3 }; // NOLINT Exception: Google Test and Abseil flags library macros. // \u2705 Okay TEST ( Foo , Bar ) { // NOLINT ... } // \u2705 Okay ABSL_FLAG ( // NOLINT std :: string , my_flag , {}, \"Description...\" );","title":"Ignore lint warnings"},{"location":"contributing/style-guide/#objective-c","text":"Follow Google's Objective-C Style Guide .","title":"Objective-C"},{"location":"contributing/style-guide/#nil-checks","text":"Exception: Do not use implicit nil checks // \u2705 Do this if ( a != nil ) // \u274c Not this if ( a )","title":"Nil checks"},{"location":"contributing/style-guide/#python","text":"Follow Google's Python Style Guide .","title":"Python"},{"location":"contributing/style-guide/#indentation","text":"Exception: Indent code with two spaces.","title":"Indentation"},{"location":"contributing/style-guide/#starlark-bazel","text":"Follow Starlark's Style Guide . Use Buildifier to style and lint Starlark files.","title":"Starlark (Bazel)"},{"location":"contributing/style-guide/#shell","text":"Follow Google's Shell Style Guide .","title":"Shell"},{"location":"contributing/style-guide/#shebang","text":"Exception: Use the shebang #!/usr/bin/env bash which is more portable. # \u2705 Do this #!/usr/bin/env bash # \u274c Not this #!/bin/bash","title":"Shebang"},{"location":"contributing/style-guide/#markdown","text":"Follow Google's Markdown Style Guide .","title":"Markdown"},{"location":"contributing/style-guide/#character-line-limit","text":"Each line should be at most 80 characters long. Exception: URLs and tables which cannot be wrapped.","title":"Character line limit"},{"location":"contributing/style-guide/#links","text":"Use reference-style links for long URLs. Use kebab-case for reference names, place references at the end of the file, and alphabetize the list. \u2705 Do this Follow [ Google's Markdown Style Guide ][ google-markdown-style-guide ]. [ google-markdown-style-guide ]: https://google.github.io/styleguide/docguide/style.html#document-layout \u274c Not this Follow [ Google's Markdown Style Guide ]( https://google.github.io/styleguide/docguide/style.html#document-layout ).","title":"Links"},{"location":"get-started/","text":"Get Started","title":"Overview"},{"location":"get-started/#get-started","text":"","title":"Get Started"},{"location":"get-started/xcode-toolchain/","text":"Xcode Toolchain Installation Download the toolchain. Copy or symlink the toolchain into ~/Library/Developer/Toolchains/ . mkdir -p ~/Library/Developer/Toolchains ln -sfn path/to/downloaded/MicrosoftSpoor.xctoolchain ~/Library/Developer/Toolchains/MicrosoftSpoor.xctoolchain There is no step 3. Usage Xcode UI xcodebuild Select Spoor from Xcode's toolchains list: Xcode > Toolchains > Spoor . Pass -toolchain Spoor to xcodebuild or set the TOOLCHAINS environment variable to Spoor .","title":"Xcode Toolchain"},{"location":"get-started/xcode-toolchain/#xcode-toolchain","text":"","title":"Xcode Toolchain"},{"location":"get-started/xcode-toolchain/#installation","text":"Download the toolchain. Copy or symlink the toolchain into ~/Library/Developer/Toolchains/ . mkdir -p ~/Library/Developer/Toolchains ln -sfn path/to/downloaded/MicrosoftSpoor.xctoolchain ~/Library/Developer/Toolchains/MicrosoftSpoor.xctoolchain There is no step 3.","title":"Installation"},{"location":"get-started/xcode-toolchain/#usage","text":"Xcode UI xcodebuild Select Spoor from Xcode's toolchains list: Xcode > Toolchains > Spoor . Pass -toolchain Spoor to xcodebuild or set the TOOLCHAINS environment variable to Spoor .","title":"Usage"},{"location":"reference/","text":"Reference spoor noun | the\u202ftrack\u202for scent of an animal verb | follow or scent\u202fof\u202f(an\u202fanimal\u202for\u202fperson) Metaphor Your application is the animal and the function traces are the scent it leaves behind. Introduction Spoor gives you deep insight into your application's performance. Its three-part toolchain enables you to analyze your application down to the function call with nanosecond precision and includes: Compiler instrumentation to auto-inject trace events. A runtime library to capture and buffer events. Tools to process and visualize the traces. Goals Spoor is designed to achieve the following goals. Develop a tool capable of collecting an exhaustive application trace including function entries and exists with highly accurate timestamps. Be language- and platform-independent. Have a virtually imperceptible performance impact when turned off and a \"usable\" performance impact when turned on. This includes deferring as much processing as possible to an offline postprocessing tool. Provide configurable parameters that allow developers to tune the runtime performance (speed, memory, and disk space) of the tracing, possibly at the expense of dropping events. Allow the instrumented application to dynamically enable tracing, disable tracing, and flush the buffers. Achieve all runtime features in-process. Project status Spoor is still in its infancy and should be considered alpha-quality software. Please anticipate breaking changes, report bugs that you encounter, and consider contributing code to support Spoor's development. Alternatives XRay XRay is a toolchain that also collects high-accuracy function traces with the ability to dynamically enable and disable tracing at runtime. At a high level, XRay's architecture is similar to Spoor's because it combines compiler-inserted instrumentation with a runtime library to collect traces. However, XRay's implementation and underlying architecture differs. XRay dynamically enables and disables tracing by patching the binary at runtime to insert or remove function entry and exit logs whereas Spoor checks if the runtime is enabled before logging. Although XRay's approach is more efficient, is does not work on Apple platforms because the kernel does not permit patching the binary at runtime due to the resulting security and performance implications. XRay is open sourced as part of the LLVM project. https://llvm.org/docs/XRay.html dtrace dtrace is a static and dynamic tracing framework that samples an application's runtime stack. Unlike Spoor, dtrace's dynamic tracing can capture non-instrumented code including operating system kernel calls and precompiled libraries, however, does not run in-process and captures samples (i.e., not an exhaustive trace) of an application. https://en.wikipedia.org/wiki/DTrace","title":"Overview"},{"location":"reference/#reference","text":"spoor noun | the\u202ftrack\u202for scent of an animal verb | follow or scent\u202fof\u202f(an\u202fanimal\u202for\u202fperson) Metaphor Your application is the animal and the function traces are the scent it leaves behind.","title":"Reference"},{"location":"reference/#introduction","text":"Spoor gives you deep insight into your application's performance. Its three-part toolchain enables you to analyze your application down to the function call with nanosecond precision and includes: Compiler instrumentation to auto-inject trace events. A runtime library to capture and buffer events. Tools to process and visualize the traces.","title":"Introduction"},{"location":"reference/#goals","text":"Spoor is designed to achieve the following goals. Develop a tool capable of collecting an exhaustive application trace including function entries and exists with highly accurate timestamps. Be language- and platform-independent. Have a virtually imperceptible performance impact when turned off and a \"usable\" performance impact when turned on. This includes deferring as much processing as possible to an offline postprocessing tool. Provide configurable parameters that allow developers to tune the runtime performance (speed, memory, and disk space) of the tracing, possibly at the expense of dropping events. Allow the instrumented application to dynamically enable tracing, disable tracing, and flush the buffers. Achieve all runtime features in-process.","title":"Goals"},{"location":"reference/#project-status","text":"Spoor is still in its infancy and should be considered alpha-quality software. Please anticipate breaking changes, report bugs that you encounter, and consider contributing code to support Spoor's development.","title":"Project status"},{"location":"reference/#alternatives","text":"","title":"Alternatives"},{"location":"reference/#xray","text":"XRay is a toolchain that also collects high-accuracy function traces with the ability to dynamically enable and disable tracing at runtime. At a high level, XRay's architecture is similar to Spoor's because it combines compiler-inserted instrumentation with a runtime library to collect traces. However, XRay's implementation and underlying architecture differs. XRay dynamically enables and disables tracing by patching the binary at runtime to insert or remove function entry and exit logs whereas Spoor checks if the runtime is enabled before logging. Although XRay's approach is more efficient, is does not work on Apple platforms because the kernel does not permit patching the binary at runtime due to the resulting security and performance implications. XRay is open sourced as part of the LLVM project. https://llvm.org/docs/XRay.html","title":"XRay"},{"location":"reference/#dtrace","text":"dtrace is a static and dynamic tracing framework that samples an application's runtime stack. Unlike Spoor, dtrace's dynamic tracing can capture non-instrumented code including operating system kernel calls and precompiled libraries, however, does not run in-process and captures samples (i.e., not an exhaustive trace) of an application. https://en.wikipedia.org/wiki/DTrace","title":"dtrace"},{"location":"reference/instrumentation/","text":"Instrumentation Introduction Spoor automatically injects instrumentation to log each function's entry and exit. This allows you to reconstruct your application's runtime stack. Supported languages Spoor's instrumentation works with LLVM-based languages such as C , C++ , and Objective-C , Rust , Swift , Kotlin , Scala , and more . Demo Check out the Fibonacci tutorial to see Spoor's instrumentation in action. Packaging Spoor's instrumentation is available in three flavors. LLVM opt plugin opt source.ll \\ -load-pass-plugin=libspoor_instrumentation.so \\ -passes=\"inject-spoor-instrumentation\" \\ -S \\ -o source_instrumented.ll Standalone executable spoor_opt --help spoor_opt: Transform LLVM Bitcode/IR by injecting Spoor instrumentation. USAGE: spoor_opt [options...] [input_file] EXAMPLES $ spoor_opt source.bc --output_file=instrumented_source.bc $ clang++ source.cc -c -emit-llvm -o - | spoor_opt | clang++ -x ir - -lspoor_runtime Reads from stdin if an input file is not provided. Prints to stdout if an output file is not provided. Flags from spoor/instrumentation/config/command_line.cc: --enable_runtime (Automatically enable Spoor's runtime.); default: true; --filters_file (File path to the filters file.); default: none; --force_binary_output (Force printing binary data to the console.); default: false; --initialize_runtime (Automatically initialize Spoor's runtime.); default: true; --inject_instrumentation (Inject Spoor instrumentation.); default: true; --module_id (Override the LLVM module's ID.); default: none; --output_file (Output file.); default: \"-\"; --output_language (Language in which to output the transformed code. Options: bitcode, ir.); default: bitcode; --output_symbols_file (Spoor instrumentation symbols output file.); default: \"\"; Try --helpfull to get a list of all flags or --help=substring shows help for flags which include specified substring in either in the name, or description or path. Xcode toolchain Spoor provides clang and swift wrappers in an .xctoolchain to conveniently integrate with Xcode and build with instrumentation on Apple platforms. See get started with Spoor's Xcode toolchain for its installation and usage. Automatic injection Spoor instruments your source code by running a custom out-of-tree optimization pass over your source code\u2019s LLVM intermediate representation. By default, it logs the funciton ID of each function it enters and exists alongside the events' timestamp. Function IDs are mapped back to the original function's properties in an emitted symbols file . define i64 @Add(i64, i64) { + call void @_spoor_runtime_LogFunctionEntry(...) %2 = add i64 %0, %1 + call void @_spoor_runtime_LogFunctionExit(...) ret i64 %2 } Additionally, by default, the instrumentation inserts calls to initialize the runtime at the start of the main function and an API call to deinitialize the runtime before each return statement in the main function. define i32 main() { + call void @_spoor_runtime_Initialize() + call void @_spoor_runtime_Enable() + call void @_spoor_runtime_LogFunctionEntry(...) + call void @_spoor_runtime_LogFunctionEntry(...) %1 = call i32 @Add(1, 2) + call void @_spoor_runtime_LogFunctionExit(...) + call void @_spoor_runtime_Deinitialize() ret i32 %1 } This behavior is configurable . Function IDs Each function is represented by a unique, unsigned 64-bit integer. This value is logged by LogFunctionEntry and LogFunctionExit . Function IDs should be treated as opaque values that are globally unique. Implementation Function IDs are composed of a module ID spanning the most significant 32 bits and a local function ID spanning the remaining (least significant) 32 bits. The module ID is a CityHash hash of the module's LLVM instructions making it (very likely to be) be globally unique. Within each module, each function is sequentially assigned a local function ID starting from 0. Example function ID 0x89ABCDEF00000001 |------||------| Module ID Local function ID Note: The implementation is subject to change and is not a value on which one should rely or assume to be stable between Spoor versions. Symbols Function IDs are mapped back to the original function's information in an emitted symbols file. This information includes the function's name, source file, line number, etc. The .spoor_symbols file is a binary Protocol Buffer that conforms to the following schema: spoor/instrumentation/symbols/symbols.proto Inspect the symbols file and symbolize traces using Spoor's postprocessing tools . Configuration Spoor's automatic instrumentation inject behavior is configurable. You can choose which functions get instrumented and if the runtime is automatically initialized and enabled. See Spoor's instrumentation configuration page for details. Function filtering Function filtering is an important optimization strategy. Spoor instruments every function by default, however, logging less improves your application's runtime performance, reduces the amount of memory that Spoor's runtime must consume to buffer the events, and speeds up Spoor's postprocessing tools. Although each application benefits from a unique set of filters tailored to its use and environment, there are a few general strategies to consider when deciding what to filter. Privacy Filter functions that could log sensitive information. For example, if you're implementing a keyboard and have button handlers didTapA() , didTapB() , didTapC() , etc., without filtering these functions you're using Spoor as a key logger! Relevance Instrument the code that you plan to optimize. For example, it might be interesting to know when your application makes a library call but not the library's implementation, especially if its implementation is noisy. Function size Most functions are very small -- just tens of IR instructions in size. It is often reasonable to apply a heuristic that functions with few instructions are fast (but might call larger and more expensive functions). Additionally, the cost of logging the function's entry and exit might exceed the cost of the function's logic itself. Thus, filtering these small function calls saves a significant amount of runtime overhead while still logging the larger and more \"interesting\" functions. 50% of functions in Wikipedia's iOS app are less than 15 IR instructions and 95% are at most 140 IR instructions. Internal experiments show that this distribution is roughly representative of other programs. Wikipedia iOS function IR instruction count distribution Percentile IR instruction count 0.5 14 0.9 76 0.95 140 0.99 406 0.999 1217 0.9999 2424","title":"Overview"},{"location":"reference/instrumentation/#instrumentation","text":"","title":"Instrumentation"},{"location":"reference/instrumentation/#introduction","text":"Spoor automatically injects instrumentation to log each function's entry and exit. This allows you to reconstruct your application's runtime stack.","title":"Introduction"},{"location":"reference/instrumentation/#supported-languages","text":"Spoor's instrumentation works with LLVM-based languages such as C , C++ , and Objective-C , Rust , Swift , Kotlin , Scala , and more .","title":"Supported languages"},{"location":"reference/instrumentation/#demo","text":"Check out the Fibonacci tutorial to see Spoor's instrumentation in action.","title":"Demo"},{"location":"reference/instrumentation/#packaging","text":"Spoor's instrumentation is available in three flavors.","title":"Packaging"},{"location":"reference/instrumentation/#llvm-opt-plugin","text":"opt source.ll \\ -load-pass-plugin=libspoor_instrumentation.so \\ -passes=\"inject-spoor-instrumentation\" \\ -S \\ -o source_instrumented.ll","title":"LLVM opt plugin"},{"location":"reference/instrumentation/#standalone-executable","text":"spoor_opt --help spoor_opt: Transform LLVM Bitcode/IR by injecting Spoor instrumentation. USAGE: spoor_opt [options...] [input_file] EXAMPLES $ spoor_opt source.bc --output_file=instrumented_source.bc $ clang++ source.cc -c -emit-llvm -o - | spoor_opt | clang++ -x ir - -lspoor_runtime Reads from stdin if an input file is not provided. Prints to stdout if an output file is not provided. Flags from spoor/instrumentation/config/command_line.cc: --enable_runtime (Automatically enable Spoor's runtime.); default: true; --filters_file (File path to the filters file.); default: none; --force_binary_output (Force printing binary data to the console.); default: false; --initialize_runtime (Automatically initialize Spoor's runtime.); default: true; --inject_instrumentation (Inject Spoor instrumentation.); default: true; --module_id (Override the LLVM module's ID.); default: none; --output_file (Output file.); default: \"-\"; --output_language (Language in which to output the transformed code. Options: bitcode, ir.); default: bitcode; --output_symbols_file (Spoor instrumentation symbols output file.); default: \"\"; Try --helpfull to get a list of all flags or --help=substring shows help for flags which include specified substring in either in the name, or description or path.","title":"Standalone executable"},{"location":"reference/instrumentation/#xcode-toolchain","text":"Spoor provides clang and swift wrappers in an .xctoolchain to conveniently integrate with Xcode and build with instrumentation on Apple platforms. See get started with Spoor's Xcode toolchain for its installation and usage.","title":"Xcode toolchain"},{"location":"reference/instrumentation/#automatic-injection","text":"Spoor instruments your source code by running a custom out-of-tree optimization pass over your source code\u2019s LLVM intermediate representation. By default, it logs the funciton ID of each function it enters and exists alongside the events' timestamp. Function IDs are mapped back to the original function's properties in an emitted symbols file . define i64 @Add(i64, i64) { + call void @_spoor_runtime_LogFunctionEntry(...) %2 = add i64 %0, %1 + call void @_spoor_runtime_LogFunctionExit(...) ret i64 %2 } Additionally, by default, the instrumentation inserts calls to initialize the runtime at the start of the main function and an API call to deinitialize the runtime before each return statement in the main function. define i32 main() { + call void @_spoor_runtime_Initialize() + call void @_spoor_runtime_Enable() + call void @_spoor_runtime_LogFunctionEntry(...) + call void @_spoor_runtime_LogFunctionEntry(...) %1 = call i32 @Add(1, 2) + call void @_spoor_runtime_LogFunctionExit(...) + call void @_spoor_runtime_Deinitialize() ret i32 %1 } This behavior is configurable .","title":"Automatic injection"},{"location":"reference/instrumentation/#function-ids","text":"Each function is represented by a unique, unsigned 64-bit integer. This value is logged by LogFunctionEntry and LogFunctionExit . Function IDs should be treated as opaque values that are globally unique. Implementation Function IDs are composed of a module ID spanning the most significant 32 bits and a local function ID spanning the remaining (least significant) 32 bits. The module ID is a CityHash hash of the module's LLVM instructions making it (very likely to be) be globally unique. Within each module, each function is sequentially assigned a local function ID starting from 0. Example function ID 0x89ABCDEF00000001 |------||------| Module ID Local function ID Note: The implementation is subject to change and is not a value on which one should rely or assume to be stable between Spoor versions.","title":"Function IDs"},{"location":"reference/instrumentation/#symbols","text":"Function IDs are mapped back to the original function's information in an emitted symbols file. This information includes the function's name, source file, line number, etc. The .spoor_symbols file is a binary Protocol Buffer that conforms to the following schema: spoor/instrumentation/symbols/symbols.proto Inspect the symbols file and symbolize traces using Spoor's postprocessing tools .","title":"Symbols"},{"location":"reference/instrumentation/#configuration","text":"Spoor's automatic instrumentation inject behavior is configurable. You can choose which functions get instrumented and if the runtime is automatically initialized and enabled. See Spoor's instrumentation configuration page for details.","title":"Configuration"},{"location":"reference/instrumentation/#function-filtering","text":"Function filtering is an important optimization strategy. Spoor instruments every function by default, however, logging less improves your application's runtime performance, reduces the amount of memory that Spoor's runtime must consume to buffer the events, and speeds up Spoor's postprocessing tools. Although each application benefits from a unique set of filters tailored to its use and environment, there are a few general strategies to consider when deciding what to filter. Privacy Filter functions that could log sensitive information. For example, if you're implementing a keyboard and have button handlers didTapA() , didTapB() , didTapC() , etc., without filtering these functions you're using Spoor as a key logger! Relevance Instrument the code that you plan to optimize. For example, it might be interesting to know when your application makes a library call but not the library's implementation, especially if its implementation is noisy. Function size Most functions are very small -- just tens of IR instructions in size. It is often reasonable to apply a heuristic that functions with few instructions are fast (but might call larger and more expensive functions). Additionally, the cost of logging the function's entry and exit might exceed the cost of the function's logic itself. Thus, filtering these small function calls saves a significant amount of runtime overhead while still logging the larger and more \"interesting\" functions. 50% of functions in Wikipedia's iOS app are less than 15 IR instructions and 95% are at most 140 IR instructions. Internal experiments show that this distribution is roughly representative of other programs. Wikipedia iOS function IR instruction count distribution Percentile IR instruction count 0.5 14 0.9 76 0.95 140 0.99 406 0.999 1217 0.9999 2424","title":"Function filtering"},{"location":"reference/instrumentation/configuration/","text":"Instrumentation Configuration Configure Spoor's instrumentation with command line flags, environment variables, or a configuration file. Precedence Command line flags ( spoor_opt ). Environment variables. Config file. Config functions Spoor does not instrument user-defined config functions to prevent recursive initialization. Instrumentation options Enable runtime Automatically enable Spoor's runtime. Type: bool Default: true Source Key Command line --enable_runtime Environment variable SPOOR_INSTRUMENTATION_ENABLE_RUNTIME Config file enable_runtime Filters file Path to the filters file . Type: string Default: Empty (no filters) Source Key Command line --filters_file Environment variable SPOOR_INSTRUMENTATION_FILTERS_FILE Config file filters_file Force binary output Force printing binary data to the console. Type: bool Default: false Source Key Command line --force_binary_output Environment variable SPOOR_INSTRUMENTATION_FORCE_BINARY_OUTPUT Config file force_binary_output Initialize runtime Automatically initialize Spoor's runtime. This is achieved by injecting a call to _spoor_runtime_Initialize() at the start of main . Type: bool Default: true Source Key Command line --initialize_runtime Environment variable SPOOR_INSTRUMENTATION_INITIALIZE_RUNTIME Config file initialize_runtime Inject instrumentation Inject Spoor instrumentation. Type: bool Default: true Source Key Command line --inject_instrumentation Environment variable SPOOR_INSTRUMENTATION_INJECT_INSTRUMENTATION Config file inject_instrumentation Module ID Override the LLVM module's ID. Type: string Default: Empty (do not override LLVM module ID) Source Key Command line --module_id Environment variable SPOOR_INSTRUMENTATION_MODULE_ID Config file module_id Output file Spoor instrumentation symbols output file. All parent directories must exist. Type: string Default: - (stdout) Source Key Command line --output_file Environment variable SPOOR_INSTRUMENTATION_OUTPUT_FILE Config file output_file Output language Language in which to output the transformed code. Type: string Options: ir or bitcode . Default value: bitcode Source Key Command line --output_language Environment variable SPOOR_INSTRUMENTATION_OUTPUT_LANGUAGE Config file output_language Output symbols file Spoor instrumentation symbols output file. All parent directories must exist. Type: string Default: Empty (error) Source Key Command line --output_symbols_file Environment variable SPOOR_INSTRUMENTATION_OUTPUT_SYMBOLS_FILE Config file output_symbols_file Xcode toolchain Preprocessor macros Spoor's clang and clang++ toolchain wrappers export the following preprocessor macros. Name Value __SPOOR__ 1 Additionally, the clang and clang++ toolchain wrappers forward the following configuration values as a preprocessor macros. Their values are adopted from the configured value or take on the default value if not specified. SPOOR_INSTRUMENTATION_ENABLE_RUNTIME SPOOR_INSTRUMENTATION_INITIALIZE_RUNTIME SPOOR_INSTRUMENTATION_INJECT_INSTRUMENTATION Configuration file Spoor's instrumentation tools search for a configuration file called spoor_config.toml from the present working directory up to root. Example configuration file # spoor_config.toml enable_runtime = true filters_file = \"/path/to/spoor_filters.toml\" force_binary_output = false initialize_runtime = true inject_instrumentation = true module_id = \"Module\" output_file = \"/path/to/output.perfetto\" output_language = \"bitcode\" output_symbols_file = \"/path/to/output.spoor_symbols\" Filters file Policy: Do not instrument functions matching a blocklist rule that do not also match an allow list rule. A function must match all conditions within in a block or allow rule to apply. All configurations are optional. Match everything An empty rule matches everything. Backslashes Escape backslashes in regular expressions. Example filters file # spoor_filters.toml [[block]] rule_name = \"Block small functions\" function_ir_instruction_count_lt = 100 [[block]] rule_name = \"Block React Native runtime\" demangled_name = \"^facebook::jsc::.*\" source_file_path = \".*/Pods/React.*\" [[allow]] rule_name = \"Always instrument `main`\" function_linkage_name = \"main\" The above config file blocks all functions that are less than 100 instructions, OR functions whose source file matches the path .*/Pods/React.* AND whose demangled name matches ^facebook::jsc::.*\" , EXCEPT for the main function which is always instrumented (regardless of its source file path or instruction count). Rule name Helpful description of the rule. If a filter matches a function during instrumentation (either blocking or allowing it), the rule's name is reported in the emitted symbols metadata. If multiple rules apply to a function, only one of the rules is reported. Type: string Source Key Config file rule_name Source file path Regular expression matching the source file path. Type: string Source Key Config file source_file_path Example source file paths /path/to/source.extension <compiler-generated> Demangled function name Regular expression matching the demangled function name. Type: string Source Key Config file function_demangled_name Example demangled function names main void std::__1::sort<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >(std::__1::__wrap_iter<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >*>, std::__1::__wrap_iter<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >*>) app_ios.Bootstrap.appDidFinish(with: Swift.Optional<Swift.Dictionary<__C.UIApplicationLaunchOptionsKey, Any>>) -> () +[RCTCxxBridge runRunLoop] Function linkage name Regular expression matching the function's linkage name. Type: string Source Key Config file function_linkage_name Example function linkage names main _ZNSt3__1L4sortINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEvNS_11__wrap_iterIPT_EESA_ $s7app_ios9BootstrapC0A9DidFinish4withySDySo29UIApplicationLaunchOptionsKeyaypGSg_tF +[RCTCxxBridge runRunLoop] Function IR instruction count less than Matches all functions with an IR instruction count strictly less than the provided value. Type: int32 Source Key Config file function_ir_instruction_count_lt Function IR instruction count greater than Matches all functions with an IR instruction count strictly greater than the provided value. Type: int32 Source Key Config file function_ir_instruction_count_gt","title":"Configuration"},{"location":"reference/instrumentation/configuration/#instrumentation-configuration","text":"Configure Spoor's instrumentation with command line flags, environment variables, or a configuration file. Precedence Command line flags ( spoor_opt ). Environment variables. Config file. Config functions Spoor does not instrument user-defined config functions to prevent recursive initialization.","title":"Instrumentation Configuration"},{"location":"reference/instrumentation/configuration/#instrumentation-options","text":"","title":"Instrumentation options"},{"location":"reference/instrumentation/configuration/#enable-runtime","text":"Automatically enable Spoor's runtime. Type: bool Default: true Source Key Command line --enable_runtime Environment variable SPOOR_INSTRUMENTATION_ENABLE_RUNTIME Config file enable_runtime","title":"Enable runtime"},{"location":"reference/instrumentation/configuration/#filters-file","text":"Path to the filters file . Type: string Default: Empty (no filters) Source Key Command line --filters_file Environment variable SPOOR_INSTRUMENTATION_FILTERS_FILE Config file filters_file","title":"Filters file"},{"location":"reference/instrumentation/configuration/#force-binary-output","text":"Force printing binary data to the console. Type: bool Default: false Source Key Command line --force_binary_output Environment variable SPOOR_INSTRUMENTATION_FORCE_BINARY_OUTPUT Config file force_binary_output","title":"Force binary output"},{"location":"reference/instrumentation/configuration/#initialize-runtime","text":"Automatically initialize Spoor's runtime. This is achieved by injecting a call to _spoor_runtime_Initialize() at the start of main . Type: bool Default: true Source Key Command line --initialize_runtime Environment variable SPOOR_INSTRUMENTATION_INITIALIZE_RUNTIME Config file initialize_runtime","title":"Initialize runtime"},{"location":"reference/instrumentation/configuration/#inject-instrumentation","text":"Inject Spoor instrumentation. Type: bool Default: true Source Key Command line --inject_instrumentation Environment variable SPOOR_INSTRUMENTATION_INJECT_INSTRUMENTATION Config file inject_instrumentation","title":"Inject instrumentation"},{"location":"reference/instrumentation/configuration/#module-id","text":"Override the LLVM module's ID. Type: string Default: Empty (do not override LLVM module ID) Source Key Command line --module_id Environment variable SPOOR_INSTRUMENTATION_MODULE_ID Config file module_id","title":"Module ID"},{"location":"reference/instrumentation/configuration/#output-file","text":"Spoor instrumentation symbols output file. All parent directories must exist. Type: string Default: - (stdout) Source Key Command line --output_file Environment variable SPOOR_INSTRUMENTATION_OUTPUT_FILE Config file output_file","title":"Output file"},{"location":"reference/instrumentation/configuration/#output-language","text":"Language in which to output the transformed code. Type: string Options: ir or bitcode . Default value: bitcode Source Key Command line --output_language Environment variable SPOOR_INSTRUMENTATION_OUTPUT_LANGUAGE Config file output_language","title":"Output language"},{"location":"reference/instrumentation/configuration/#output-symbols-file","text":"Spoor instrumentation symbols output file. All parent directories must exist. Type: string Default: Empty (error) Source Key Command line --output_symbols_file Environment variable SPOOR_INSTRUMENTATION_OUTPUT_SYMBOLS_FILE Config file output_symbols_file","title":"Output symbols file"},{"location":"reference/instrumentation/configuration/#xcode-toolchain","text":"","title":"Xcode toolchain"},{"location":"reference/instrumentation/configuration/#preprocessor-macros","text":"Spoor's clang and clang++ toolchain wrappers export the following preprocessor macros. Name Value __SPOOR__ 1 Additionally, the clang and clang++ toolchain wrappers forward the following configuration values as a preprocessor macros. Their values are adopted from the configured value or take on the default value if not specified. SPOOR_INSTRUMENTATION_ENABLE_RUNTIME SPOOR_INSTRUMENTATION_INITIALIZE_RUNTIME SPOOR_INSTRUMENTATION_INJECT_INSTRUMENTATION","title":"Preprocessor macros"},{"location":"reference/instrumentation/configuration/#configuration-file","text":"Spoor's instrumentation tools search for a configuration file called spoor_config.toml from the present working directory up to root. Example configuration file # spoor_config.toml enable_runtime = true filters_file = \"/path/to/spoor_filters.toml\" force_binary_output = false initialize_runtime = true inject_instrumentation = true module_id = \"Module\" output_file = \"/path/to/output.perfetto\" output_language = \"bitcode\" output_symbols_file = \"/path/to/output.spoor_symbols\"","title":"Configuration file"},{"location":"reference/instrumentation/configuration/#filters-file_1","text":"Policy: Do not instrument functions matching a blocklist rule that do not also match an allow list rule. A function must match all conditions within in a block or allow rule to apply. All configurations are optional. Match everything An empty rule matches everything. Backslashes Escape backslashes in regular expressions. Example filters file # spoor_filters.toml [[block]] rule_name = \"Block small functions\" function_ir_instruction_count_lt = 100 [[block]] rule_name = \"Block React Native runtime\" demangled_name = \"^facebook::jsc::.*\" source_file_path = \".*/Pods/React.*\" [[allow]] rule_name = \"Always instrument `main`\" function_linkage_name = \"main\" The above config file blocks all functions that are less than 100 instructions, OR functions whose source file matches the path .*/Pods/React.* AND whose demangled name matches ^facebook::jsc::.*\" , EXCEPT for the main function which is always instrumented (regardless of its source file path or instruction count).","title":"Filters file"},{"location":"reference/instrumentation/configuration/#rule-name","text":"Helpful description of the rule. If a filter matches a function during instrumentation (either blocking or allowing it), the rule's name is reported in the emitted symbols metadata. If multiple rules apply to a function, only one of the rules is reported. Type: string Source Key Config file rule_name","title":"Rule name"},{"location":"reference/instrumentation/configuration/#source-file-path","text":"Regular expression matching the source file path. Type: string Source Key Config file source_file_path Example source file paths /path/to/source.extension <compiler-generated>","title":"Source file path"},{"location":"reference/instrumentation/configuration/#demangled-function-name","text":"Regular expression matching the demangled function name. Type: string Source Key Config file function_demangled_name Example demangled function names main void std::__1::sort<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >(std::__1::__wrap_iter<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >*>, std::__1::__wrap_iter<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >*>) app_ios.Bootstrap.appDidFinish(with: Swift.Optional<Swift.Dictionary<__C.UIApplicationLaunchOptionsKey, Any>>) -> () +[RCTCxxBridge runRunLoop]","title":"Demangled function name"},{"location":"reference/instrumentation/configuration/#function-linkage-name","text":"Regular expression matching the function's linkage name. Type: string Source Key Config file function_linkage_name Example function linkage names main _ZNSt3__1L4sortINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEvNS_11__wrap_iterIPT_EESA_ $s7app_ios9BootstrapC0A9DidFinish4withySDySo29UIApplicationLaunchOptionsKeyaypGSg_tF +[RCTCxxBridge runRunLoop]","title":"Function linkage name"},{"location":"reference/instrumentation/configuration/#function-ir-instruction-count-less-than","text":"Matches all functions with an IR instruction count strictly less than the provided value. Type: int32 Source Key Config file function_ir_instruction_count_lt","title":"Function IR instruction count less than"},{"location":"reference/instrumentation/configuration/#function-ir-instruction-count-greater-than","text":"Matches all functions with an IR instruction count strictly greater than the provided value. Type: int32 Source Key Config file function_ir_instruction_count_gt","title":"Function IR instruction count greater than"},{"location":"reference/postprocessing/","text":"Postprocessing Introduction Spoor's postprocessing tool parses and symbolizes trace data generated at runtime and converts these data into human-readable formats. Packaging Spoor's postprocessing tools are packaged as a command line tool. spoor --help spoor: Parse and symbolize Spoor traces. USAGE: spoor [options...] <search_paths...> Flags from spoor/tools/config/command_line_config.cc: --output_file (Output file.); default: \"\"; --output_format (Data output format. Options: automatic, perfetto, spoor_symbols, csv. \"automatic\" detects the format from the output file's extension.); default: automatic; Try --helpfull to get a list of all flags or --help=substring shows help for flags which include specified substring in either in the name, or description or path. Output formats The command line tool infers the file output format from the output_file 's extension. Perfetto Outputs a Perfetto -compatible trace file that can be visualized in Perfetto's trace viewer . Spoor symbols Aggregates one or more .spoor_symbols files into a single .spoor_symbols file. CSV Aggregates one or more .spoor_symbols files, then outputs these symbols data as a semicolon-delimited text file. This is useful for parsing the symbols data in other programs.","title":"Overview"},{"location":"reference/postprocessing/#postprocessing","text":"","title":"Postprocessing"},{"location":"reference/postprocessing/#introduction","text":"Spoor's postprocessing tool parses and symbolizes trace data generated at runtime and converts these data into human-readable formats.","title":"Introduction"},{"location":"reference/postprocessing/#packaging","text":"Spoor's postprocessing tools are packaged as a command line tool. spoor --help spoor: Parse and symbolize Spoor traces. USAGE: spoor [options...] <search_paths...> Flags from spoor/tools/config/command_line_config.cc: --output_file (Output file.); default: \"\"; --output_format (Data output format. Options: automatic, perfetto, spoor_symbols, csv. \"automatic\" detects the format from the output file's extension.); default: automatic; Try --helpfull to get a list of all flags or --help=substring shows help for flags which include specified substring in either in the name, or description or path.","title":"Packaging"},{"location":"reference/postprocessing/#output-formats","text":"The command line tool infers the file output format from the output_file 's extension.","title":"Output formats"},{"location":"reference/postprocessing/#perfetto","text":"Outputs a Perfetto -compatible trace file that can be visualized in Perfetto's trace viewer .","title":"Perfetto"},{"location":"reference/postprocessing/#spoor-symbols","text":"Aggregates one or more .spoor_symbols files into a single .spoor_symbols file.","title":"Spoor symbols"},{"location":"reference/postprocessing/#csv","text":"Aggregates one or more .spoor_symbols files, then outputs these symbols data as a semicolon-delimited text file. This is useful for parsing the symbols data in other programs.","title":"CSV"},{"location":"reference/runtime/","text":"Runtime Introduction Spoor's runtime is responsible for efficiently buffering trace events and flushing them to disk. API Supported languages Spoor's runtime is written in C++ and can be extended to work in any language. Spoor currently offers C++ and Objective-C APIs, and we welcome contributions that expose Spoor APIs natively to other languages. Language Header C++ spoor/runtime/runtime.h Objective-C spoor/runtime/wrappers/apple/Runtime.h Packaging Spoor's runtime is offered in both static and dynamic variants. Additionally, the runtime has a stub implementation with a significantly smaller binary size. This is helpful when you only want to use Spoor in development, testing, or dogfood environments (but not in production) -- just conditionally link against either the full or stub implementation during your build. Spoor's runtime also comes packaged as an XCFramework for use on Apple platforms. Runtime modes Spoor's runtime can operate in two modes: Log everything mode and circular buffer mode. Dropped events Spoor drops events (instead of blocking the thread) if there is insufficient memory in the buffer pool to hold the event. When the buffer pool reaches capacity, the runtime flushes each thread in an attempt to reclaim memory. Log everything As the name suggests, all events are flushed to disk. A flush event can occur manually, when a thread is relinquished, when the buffer pool reaches capacity, or when the runtime is deinitialized. Circular buffer In circular buffer mode, new events on a thread override old events when the thread's circular buffer reaches capacity. When a thread is relinquished, the flush queue retains the thread's events for a configurable duration in anticipation of a manual flush event. Buffered events are flushed to disk when you issue a manual flush event. Trace Trace files are composed of a header followed by n events. Source code spoor/runtime/trace/trace.h Header Magic number 0xc853706f6f720d0a1a0a , Spoor's 80-bit trace file magic number. Endianness Value representing the endianness of the system that generated the trace file. Compression strategy Value representing the compression strategy used to compress the trace events in the file. Version Value representing the trace file's version. Session ID Identifies the session that captured the trace events. The session ID is a random number by default to uniquely identify each run but is configurable to easily aggregate traces across multiple runs or processes. Process ID Identifies the process that captured the trace events. Thread ID Identifies the thread that captured the trace events within the process. System clock timestamp Number of nanoseconds since the system clock's epoch used to derive the wall clock time. Steady clock timestamp Number of nanoseconds since the steady clock's epoch. The value is recorded shortly after (effectively at the same time as) the system clock timestamp and is used to convert the steady clock's time to the system clock's time. Event count Number of events in the trace file. Padding Empty space to pad the header to 64 bytes. Event Trace events are designed to be very small, just 24 bytes, and are composed of three pieces of data. Event ID The event ID represents the type of event and are represented by a 32-bit integer. The two most common events are function entry and function exit events. Namespace Events with a most significant bit of 0 are reserved. Timestamp The timestamp is number of nanoseconds that have elapsed since the steady clock's epoch. Payload The payload is a fixed 96 bits (composed of a 64-bit integer and a 32-bit integer) for an event to store auxiliary data. The payload is fixed size to encourage developers to efficiently store their event's data (instead of, for example, logging a string). Two common strategies to fit an event into the payload include symbolizing static strings (e.g., log messages) and hashing dynamic strings (e.g., account email addresses). Architecture Spoor's runtime architecture. runtime-architecture.pdf Event buffer path Notice the beautiful circular path that the event buffer follows. Memory management Spoor events are buffered on each thread before being flushed to disk. Buffer pool Event buffers are acquired from a global object pool and come in two varieties: static and dynamic. Static buffers are allocated during Spoor's initialization and deallocated during deinitialization. Dynamic buffers are allocated adhoc and deallocated as soon as they are returned to the pool. An application can have a combination of static and dynamic buffers in the pool. This is useful when your application has a predicable and constant event volume. In this case, you reserve a certain amount of memory in the static pool. However, if your app also has occasional spikes in event volume and you do not wish to drop events or over-allocate the static pool, you can choose to dynamically allocate buffers to hold the remaining events. The buffer's behavior is highly configurable so that you can tune Spoor's runtime behavior for your use case. Thread logger Each thread has a thread-local buffer into which it logs events. A thread's buffer has a maximum capacity, however, it does not request the full capacity from the global buffer pool all at once. Instead, it acquires the buffer in slices . This ensues that low-volume background threads do not over-reserve capacity from the buffer pool.","title":"Overview"},{"location":"reference/runtime/#runtime","text":"","title":"Runtime"},{"location":"reference/runtime/#introduction","text":"Spoor's runtime is responsible for efficiently buffering trace events and flushing them to disk.","title":"Introduction"},{"location":"reference/runtime/#api","text":"","title":"API"},{"location":"reference/runtime/#supported-languages","text":"Spoor's runtime is written in C++ and can be extended to work in any language. Spoor currently offers C++ and Objective-C APIs, and we welcome contributions that expose Spoor APIs natively to other languages. Language Header C++ spoor/runtime/runtime.h Objective-C spoor/runtime/wrappers/apple/Runtime.h","title":"Supported languages"},{"location":"reference/runtime/#packaging","text":"Spoor's runtime is offered in both static and dynamic variants. Additionally, the runtime has a stub implementation with a significantly smaller binary size. This is helpful when you only want to use Spoor in development, testing, or dogfood environments (but not in production) -- just conditionally link against either the full or stub implementation during your build. Spoor's runtime also comes packaged as an XCFramework for use on Apple platforms.","title":"Packaging"},{"location":"reference/runtime/#runtime-modes","text":"Spoor's runtime can operate in two modes: Log everything mode and circular buffer mode. Dropped events Spoor drops events (instead of blocking the thread) if there is insufficient memory in the buffer pool to hold the event. When the buffer pool reaches capacity, the runtime flushes each thread in an attempt to reclaim memory.","title":"Runtime modes"},{"location":"reference/runtime/#log-everything","text":"As the name suggests, all events are flushed to disk. A flush event can occur manually, when a thread is relinquished, when the buffer pool reaches capacity, or when the runtime is deinitialized.","title":"Log everything"},{"location":"reference/runtime/#circular-buffer","text":"In circular buffer mode, new events on a thread override old events when the thread's circular buffer reaches capacity. When a thread is relinquished, the flush queue retains the thread's events for a configurable duration in anticipation of a manual flush event. Buffered events are flushed to disk when you issue a manual flush event.","title":"Circular buffer"},{"location":"reference/runtime/#trace","text":"Trace files are composed of a header followed by n events.","title":"Trace"},{"location":"reference/runtime/#source-code","text":"spoor/runtime/trace/trace.h","title":"Source code"},{"location":"reference/runtime/#header","text":"","title":"Header"},{"location":"reference/runtime/#magic-number","text":"0xc853706f6f720d0a1a0a , Spoor's 80-bit trace file magic number.","title":"Magic number"},{"location":"reference/runtime/#endianness","text":"Value representing the endianness of the system that generated the trace file.","title":"Endianness"},{"location":"reference/runtime/#compression-strategy","text":"Value representing the compression strategy used to compress the trace events in the file.","title":"Compression strategy"},{"location":"reference/runtime/#version","text":"Value representing the trace file's version.","title":"Version"},{"location":"reference/runtime/#session-id","text":"Identifies the session that captured the trace events. The session ID is a random number by default to uniquely identify each run but is configurable to easily aggregate traces across multiple runs or processes.","title":"Session ID"},{"location":"reference/runtime/#process-id","text":"Identifies the process that captured the trace events.","title":"Process ID"},{"location":"reference/runtime/#thread-id","text":"Identifies the thread that captured the trace events within the process.","title":"Thread ID"},{"location":"reference/runtime/#system-clock-timestamp","text":"Number of nanoseconds since the system clock's epoch used to derive the wall clock time.","title":"System clock timestamp"},{"location":"reference/runtime/#steady-clock-timestamp","text":"Number of nanoseconds since the steady clock's epoch. The value is recorded shortly after (effectively at the same time as) the system clock timestamp and is used to convert the steady clock's time to the system clock's time.","title":"Steady clock timestamp"},{"location":"reference/runtime/#event-count","text":"Number of events in the trace file.","title":"Event count"},{"location":"reference/runtime/#padding","text":"Empty space to pad the header to 64 bytes.","title":"Padding"},{"location":"reference/runtime/#event","text":"Trace events are designed to be very small, just 24 bytes, and are composed of three pieces of data.","title":"Event"},{"location":"reference/runtime/#event-id","text":"The event ID represents the type of event and are represented by a 32-bit integer. The two most common events are function entry and function exit events. Namespace Events with a most significant bit of 0 are reserved.","title":"Event ID"},{"location":"reference/runtime/#timestamp","text":"The timestamp is number of nanoseconds that have elapsed since the steady clock's epoch.","title":"Timestamp"},{"location":"reference/runtime/#payload","text":"The payload is a fixed 96 bits (composed of a 64-bit integer and a 32-bit integer) for an event to store auxiliary data. The payload is fixed size to encourage developers to efficiently store their event's data (instead of, for example, logging a string). Two common strategies to fit an event into the payload include symbolizing static strings (e.g., log messages) and hashing dynamic strings (e.g., account email addresses).","title":"Payload"},{"location":"reference/runtime/#architecture","text":"Spoor's runtime architecture. runtime-architecture.pdf Event buffer path Notice the beautiful circular path that the event buffer follows.","title":"Architecture"},{"location":"reference/runtime/#memory-management","text":"Spoor events are buffered on each thread before being flushed to disk.","title":"Memory management"},{"location":"reference/runtime/#buffer-pool","text":"Event buffers are acquired from a global object pool and come in two varieties: static and dynamic. Static buffers are allocated during Spoor's initialization and deallocated during deinitialization. Dynamic buffers are allocated adhoc and deallocated as soon as they are returned to the pool. An application can have a combination of static and dynamic buffers in the pool. This is useful when your application has a predicable and constant event volume. In this case, you reserve a certain amount of memory in the static pool. However, if your app also has occasional spikes in event volume and you do not wish to drop events or over-allocate the static pool, you can choose to dynamically allocate buffers to hold the remaining events. The buffer's behavior is highly configurable so that you can tune Spoor's runtime behavior for your use case.","title":"Buffer pool"},{"location":"reference/runtime/#thread-logger","text":"Each thread has a thread-local buffer into which it logs events. A thread's buffer has a maximum capacity, however, it does not request the full capacity from the global buffer pool all at once. Instead, it acquires the buffer in slices . This ensues that low-volume background threads do not over-reserve capacity from the buffer pool.","title":"Thread logger"},{"location":"reference/runtime/configuration/","text":"Runtime Configuration Configure Spoor's runtime with environment variables or a configuration file. Precedence Environment variables. Config file. Runtime options Trace file path Directory in which to save flushed trace files. Type: string Default: . Source Key Environment variable SPOOR_RUNTIME_TRACE_FILE_PATH Config file trace_file_path Environment variable expansion Spoor automatically expands environment variables. A tilde (i.e., ~ ) expands to the value of $HOME . Compression strategy Strategy used to compress the trace file on flush. Type: string Options: none or snappy Default: snappy Source Key Environment variable SPOOR_RUNTIME_COMPRESSION_STRATEGY Config file compression_strategy Compression ratio Snappy offers a ~3x compression ratio. Session ID Session identifier used to differentiate between runs. Type: uint64 Default: Random number (likely distinct for each launch) Source Key Environment variable SPOOR_RUNTIME_SESSION_ID Config file session_id Thread event buffer capacity Maximum number of events (zero or more slices) a thread may hold in its buffer. Type: uint64 Default: 10,000 Source Key Environment variable SPOOR_RUNTIME_THEAD_EVENT_BUFFER_CAPACITY Config file thread_event_buffer_capacity Max reserved event buffer slice capacity Maximum number of events that a thread event buffer may request at once from the reserved pool. These events are stored in a contiguous slice of memory. Type: uint64 Default: 1,000 Source Key Environment variable SPOOR_RUNTIME_MAX_RESERVED_EVENT_BUFFER_SLICE_CAPACITY Config file max_reserved_event_buffer_slice_capacity Max dynamic event buffer slice capacity Maximum number of events that a thread event buffer may request at once from the dynamic pool. These events are stored in a contiguous slice of memory. Type: uint64 Default: 1,000 Source Key Environment variable SPOOR_RUNTIME_MAX_DYNAMIC_EVENT_BUFFER_SLICE_CAPACITY Config file max_dynamic_event_buffer_slice_capacity Reserved event pool capacity Event object pool size. The reserved pool is (dynamically) allocated as a continuous block of memory on initialization and released on deinitialization. Type: uint64 Default: 0 Source Key Environment variable SPOOR_RUNTIME_RESERVED_EVENT_POOL_CAPACITY Config file reserved_event_pool_capacity Dynamic event pool capacity Maximum number of events that can be dynamically allocated. Type: uint64 Default: 18,446,744,073,709,551,615 (i.e., max(uint64) ) Source Key Environment variable SPOOR_RUNTIME_DYNAMIC_EVENT_POOL_CAPACITY Config file dynamic_event_pool_capacity Dynamic event slice borrow CAS attempts Number of compare and swap attempts to borrow a slice from the dynamic buffer pool. Type: uint64 Default: 1 Source Key Environment variable SPOOR_RUNTIME_DYNAMIC_EVENT_SLICE_BORROW_CAS_ATTEMPTS Config file dynamic_event_slice_borrow_cas_attempts Event buffer retention duration Duration in nanoseconds to retain a thread's buffer after a thread ends (in anticipation of a flush event). This value is ignored when flush all events is true . Type: int64 Default: 0 Source Key Environment variable SPOOR_RUNTIME_EVENT_BUFFER_RETENTION_DURATION_NANOSECONDS Config file event_buffer_retention_duration_nanoseconds Max flush buffer to file attempts Maximum number of attempts to flush a buffer before discarding it. Type: int32 Default: 2 Source Key Environment variable SPOOR_RUNTIME_MAX_FLUSH_BUFFER_TO_FILE_ATTEMPTS Config file max_flush_buffer_to_file_attempts Flush all events When true , flushes a buffer as soon as it fills. When false , the buffer acts as a circular buffer and old events are overridden. Type: bool Default: true Source Key Environment variable SPOOR_RUNTIME_FLUSH_ALL_EVENTS Config file flush_all_events Configuration file To set a configuration file, implement the symbol spoor::runtime::ConfigFilePath() . Return std::nullopt or link against libspoor_runtime_default_config.a to use the default config. // spoor_config.cc namespace spoor :: runtime { auto ConfigFilePath () -> std :: optional < std :: string > { return \"/path/to/spoor_runtime_config.toml\" ; } } // namespace spoor::runtime Example configuration file # spoor_runtime_config.toml trace_file_path = \"/path/to/trace/\" compression_strategy = \"snappy\" session_id = 42 thread_event_buffer_capacity = 1 _000_000 max_reserved_event_buffer_slice_capacity = 1 _000_000 max_dynamic_event_buffer_slice_capacity = 1 _000_000 reserved_event_pool_capacity = 10 _000_000 dynamic_event_pool_capacity = 9 _223_372_036_854_775_807 dynamic_event_slice_borrow_cas_attempts = 1 event_buffer_retention_duration_nanoseconds = 10 _000_000_000 max_flush_buffer_to_file_attempts = 2 flush_all_events = true Config file max value Many configuration types are unsigned 64-bit integers, however, TOML only supports up to signed 64-bit integers. Therefore, the maximum possilbe value in the config file is max(int64) = 9,223,372,036,854,775,807 , not max(uint64) = 18,446,744,073,709,551,615 . See microsoft/spoor/issues/219 . Calculating memory impact event size = 24 bytes min memory impact = event_size * reserved event pool capacity max memory impact = min memory impact + event size * dynamic event pool capacity","title":"Configuration"},{"location":"reference/runtime/configuration/#runtime-configuration","text":"Configure Spoor's runtime with environment variables or a configuration file. Precedence Environment variables. Config file.","title":"Runtime Configuration"},{"location":"reference/runtime/configuration/#runtime-options","text":"","title":"Runtime options"},{"location":"reference/runtime/configuration/#trace-file-path","text":"Directory in which to save flushed trace files. Type: string Default: . Source Key Environment variable SPOOR_RUNTIME_TRACE_FILE_PATH Config file trace_file_path Environment variable expansion Spoor automatically expands environment variables. A tilde (i.e., ~ ) expands to the value of $HOME .","title":"Trace file path"},{"location":"reference/runtime/configuration/#compression-strategy","text":"Strategy used to compress the trace file on flush. Type: string Options: none or snappy Default: snappy Source Key Environment variable SPOOR_RUNTIME_COMPRESSION_STRATEGY Config file compression_strategy Compression ratio Snappy offers a ~3x compression ratio.","title":"Compression strategy"},{"location":"reference/runtime/configuration/#session-id","text":"Session identifier used to differentiate between runs. Type: uint64 Default: Random number (likely distinct for each launch) Source Key Environment variable SPOOR_RUNTIME_SESSION_ID Config file session_id","title":"Session ID"},{"location":"reference/runtime/configuration/#thread-event-buffer-capacity","text":"Maximum number of events (zero or more slices) a thread may hold in its buffer. Type: uint64 Default: 10,000 Source Key Environment variable SPOOR_RUNTIME_THEAD_EVENT_BUFFER_CAPACITY Config file thread_event_buffer_capacity","title":"Thread event buffer capacity"},{"location":"reference/runtime/configuration/#max-reserved-event-buffer-slice-capacity","text":"Maximum number of events that a thread event buffer may request at once from the reserved pool. These events are stored in a contiguous slice of memory. Type: uint64 Default: 1,000 Source Key Environment variable SPOOR_RUNTIME_MAX_RESERVED_EVENT_BUFFER_SLICE_CAPACITY Config file max_reserved_event_buffer_slice_capacity","title":"Max reserved event buffer slice capacity"},{"location":"reference/runtime/configuration/#max-dynamic-event-buffer-slice-capacity","text":"Maximum number of events that a thread event buffer may request at once from the dynamic pool. These events are stored in a contiguous slice of memory. Type: uint64 Default: 1,000 Source Key Environment variable SPOOR_RUNTIME_MAX_DYNAMIC_EVENT_BUFFER_SLICE_CAPACITY Config file max_dynamic_event_buffer_slice_capacity","title":"Max dynamic event buffer slice capacity"},{"location":"reference/runtime/configuration/#reserved-event-pool-capacity","text":"Event object pool size. The reserved pool is (dynamically) allocated as a continuous block of memory on initialization and released on deinitialization. Type: uint64 Default: 0 Source Key Environment variable SPOOR_RUNTIME_RESERVED_EVENT_POOL_CAPACITY Config file reserved_event_pool_capacity","title":"Reserved event pool capacity"},{"location":"reference/runtime/configuration/#dynamic-event-pool-capacity","text":"Maximum number of events that can be dynamically allocated. Type: uint64 Default: 18,446,744,073,709,551,615 (i.e., max(uint64) ) Source Key Environment variable SPOOR_RUNTIME_DYNAMIC_EVENT_POOL_CAPACITY Config file dynamic_event_pool_capacity","title":"Dynamic event pool capacity"},{"location":"reference/runtime/configuration/#dynamic-event-slice-borrow-cas-attempts","text":"Number of compare and swap attempts to borrow a slice from the dynamic buffer pool. Type: uint64 Default: 1 Source Key Environment variable SPOOR_RUNTIME_DYNAMIC_EVENT_SLICE_BORROW_CAS_ATTEMPTS Config file dynamic_event_slice_borrow_cas_attempts","title":"Dynamic event slice borrow CAS attempts"},{"location":"reference/runtime/configuration/#event-buffer-retention-duration","text":"Duration in nanoseconds to retain a thread's buffer after a thread ends (in anticipation of a flush event). This value is ignored when flush all events is true . Type: int64 Default: 0 Source Key Environment variable SPOOR_RUNTIME_EVENT_BUFFER_RETENTION_DURATION_NANOSECONDS Config file event_buffer_retention_duration_nanoseconds","title":"Event buffer retention duration"},{"location":"reference/runtime/configuration/#max-flush-buffer-to-file-attempts","text":"Maximum number of attempts to flush a buffer before discarding it. Type: int32 Default: 2 Source Key Environment variable SPOOR_RUNTIME_MAX_FLUSH_BUFFER_TO_FILE_ATTEMPTS Config file max_flush_buffer_to_file_attempts","title":"Max flush buffer to file attempts"},{"location":"reference/runtime/configuration/#flush-all-events","text":"When true , flushes a buffer as soon as it fills. When false , the buffer acts as a circular buffer and old events are overridden. Type: bool Default: true Source Key Environment variable SPOOR_RUNTIME_FLUSH_ALL_EVENTS Config file flush_all_events","title":"Flush all events"},{"location":"reference/runtime/configuration/#configuration-file","text":"To set a configuration file, implement the symbol spoor::runtime::ConfigFilePath() . Return std::nullopt or link against libspoor_runtime_default_config.a to use the default config. // spoor_config.cc namespace spoor :: runtime { auto ConfigFilePath () -> std :: optional < std :: string > { return \"/path/to/spoor_runtime_config.toml\" ; } } // namespace spoor::runtime Example configuration file # spoor_runtime_config.toml trace_file_path = \"/path/to/trace/\" compression_strategy = \"snappy\" session_id = 42 thread_event_buffer_capacity = 1 _000_000 max_reserved_event_buffer_slice_capacity = 1 _000_000 max_dynamic_event_buffer_slice_capacity = 1 _000_000 reserved_event_pool_capacity = 10 _000_000 dynamic_event_pool_capacity = 9 _223_372_036_854_775_807 dynamic_event_slice_borrow_cas_attempts = 1 event_buffer_retention_duration_nanoseconds = 10 _000_000_000 max_flush_buffer_to_file_attempts = 2 flush_all_events = true Config file max value Many configuration types are unsigned 64-bit integers, however, TOML only supports up to signed 64-bit integers. Therefore, the maximum possilbe value in the config file is max(int64) = 9,223,372,036,854,775,807 , not max(uint64) = 18,446,744,073,709,551,615 . See microsoft/spoor/issues/219 .","title":"Configuration file"},{"location":"reference/runtime/configuration/#calculating-memory-impact","text":"event size = 24 bytes min memory impact = event_size * reserved event pool capacity max memory impact = min memory impact + event size * dynamic event pool capacity","title":"Calculating memory impact"},{"location":"tutorials/","text":"Tutorials Fibonacci (Hello, World!) Use Spoor to instrument a simple program that calculates the Fibonacci numbers. You'll learn the basics of Spoor and how to manually compile, instrument, and link a program with Spoor. You'll learn Spoor's pipeline to automatically inject instrumentation into your source code, build and run your Spoor-instrumented program, symbolize the trace, and visualize and analyze your symbolized trace using Perfetto. Get started Wikipedia iOS (Xcode toolchain) Use Spoor to instrument Wikipedia's iOS app. You'll learn how to use Spoor's Xcode toolchain to automatically instrument an iOS app. Get started","title":"Overview"},{"location":"tutorials/#tutorials","text":"","title":"Tutorials"},{"location":"tutorials/#fibonacci-hello-world","text":"Use Spoor to instrument a simple program that calculates the Fibonacci numbers. You'll learn the basics of Spoor and how to manually compile, instrument, and link a program with Spoor. You'll learn Spoor's pipeline to automatically inject instrumentation into your source code, build and run your Spoor-instrumented program, symbolize the trace, and visualize and analyze your symbolized trace using Perfetto. Get started","title":"Fibonacci (Hello, World!)"},{"location":"tutorials/#wikipedia-ios-xcode-toolchain","text":"Use Spoor to instrument Wikipedia's iOS app. You'll learn how to use Spoor's Xcode toolchain to automatically instrument an iOS app. Get started","title":"Wikipedia iOS (Xcode toolchain)"},{"location":"tutorials/fibonacci/","text":"Fibonacci This tutorial uses Spoor to instrument a program that calculates Fibonacci numbers . You'll learn Spoor's pipeline to automatically inject instrumentation into your source code, build and run your Spoor-instrumented program, symbolize the trace, and visualize and analyze your symbolized trace using Perfetto. 0. Prerequisites 0.1 Setup and dependencies You will need: Spoor's toolchain including spoor_opt : Compiler instrumentation libspoor_runtime.a : Runtime library libspoor_runtime_default_config.a : Runtime library default configuration spoor : Postprocessing tool clang++ , rustc , swiftc , or another LLVM-based compiler of your choice. clang++ to assemble the IR and link in the standard library. A hop, a skip, and a can-do attitude. Version This tutorial uses the following tools. Your mileage may vary with newer or older versions. spoor_opt spoor_opt --version spoor_opt 0.0.0 Based on LLVM 13.0.1 libspoor_runtime 0.0.0 spoor spoor --version spoor 0.0.0 clang++ clang++ version clang version 12.0.1 C++ Rust Swift clang++ version clang version 12.0.1 rustc --version rustc 1.55.0 swiftc --version swift-driver version: 1.26.9 Apple Swift version 5.5 0.2 Write your code The Fibonacci numbers, denoted \\(F_n\\) , form a sequence where each number is the sum of the two preceding ones, starting from 0 and 1. That is, \\[ \\begin{align} F_0 &= 0 \\\\ F_1 &= 1 \\\\ F_n &= F_{n-1} + F_{n-2}, \\quad n > 1 \\end{align} \\] \\[ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \\ldots \\] This recursive definition can be implemented as follows: C++ Rust Swift // fib.cc #include <cstdio> auto Fib ( const int n ) -> int { if ( n < 2 ) return n ; return Fib ( n - 1 ) + Fib ( n - 2 ); } auto main () -> int { constexpr auto n = 46 ; const auto f = Fib ( n ); printf ( \"Fib(%d) = %d \\n \" , n , f ); } // fib.rs fn fib ( n : i64 ) -> i64 { if n < 2 { return n ; } return fib ( n - 1 ) + fib ( n - 2 ) } fn main () { let n = 10 ; let f = fib ( n ); println! ( \"Fib({}) = {}\" , n , f ); } // fib.swift import Foundation func fib ( _ n : Int ) -> Int { if n < 2 { return n } return fib ( n - 1 ) + fib ( n - 2 ) } let n = 10 let f = fib ( n ) print ( \"Fib( \\( n ) ) = \\( f ) \" ) Sanity test Build and run your (uninstrumented) code to make sure that everything works as expected. C++ Rust Swift clang++ fib.cc -o fib && ./fib rustc fib.rs && ./fib swiftc fib.swift && ./fib Fib(10) = 55 1. Instrument your code Spoor works by instrumenting LLVM IR , a common intermediate representation between your high-level source code and machine code for LLVM-based languages. 1.1 Emit IR Emit LLVM IR instead of compiling down to an object file. C++ Rust Swift clang++ fib.cc -emit-llvm -S -o fib.ll rustc fib.rs --emit llvm-ir -o fib.ll swiftc fib.swift -emit-ir -o fib.ll Debug data Compile with debug data ( -g ) to include the source file and line number in the symbolized trace. Inspect the file fib.ll to view the (uninstrumented) IR. Each language's emitted IR is different due to the nature of the source language and its compiler frontend, but they are all functionally equivalent. C++ Rust Swift ; fib.ll define dso_local i32 @_Z3Fibi ( i32 %0 ) #0 { %2 = alloca i32 , align 4 %3 = alloca i32 , align 4 store i32 %0 , i32 * %3 , align 4 %4 = load i32 , i32 * %3 , align 4 %5 = icmp slt i32 %4 , 2 br i1 %5 , label %6 , label %8 6: ; preds = %1 %7 = load i32 , i32 * %3 , align 4 store i32 %7 , i32 * %2 , align 4 br label %16 8: ; preds = %1 %9 = load i32 , i32 * %3 , align 4 %10 = sub nsw i32 %9 , 1 %11 = call i32 @_Z3Fibi ( i32 %10 ) %12 = load i32 , i32 * %3 , align 4 %13 = sub nsw i32 %12 , 2 %14 = call i32 @_Z3Fibi ( i32 %13 ) %15 = add nsw i32 %11 , %14 store i32 %15 , i32 * %2 , align 4 br label %16 16: ; preds = %8, %6 %17 = load i32 , i32 * %2 , align 4 ret i32 %17 } ; fib.ll define internal i64 @_ZN3fib3fib17h03330887093d3356E ( i64 %n ) unnamed_addr #1 { start: %0 = alloca i64 , align 8 %_2 = icmp slt i64 %n , 2 br i1 %_2 , label %bb1 , label %bb2 bb2: ; preds = %start %1 = call { i64 , i1 } @llvm.ssub.with.overflow.i64 ( i64 %n , i64 1 ) %_7.0 = extractvalue { i64 , i1 } %1 , 0 %_7.1 = extractvalue { i64 , i1 } %1 , 1 %2 = call i1 @llvm.expect.i1 ( i1 %_7.1 , i1 false ) br i1 %2 , label %panic , label %bb3 bb1: ; preds = %start store i64 %n , i64 * %0 , align 8 br label %bb8 bb8: ; preds = %bb7, %bb1 %3 = load i64 , i64 * %0 , align 8 ret i64 %3 bb3: ; preds = %bb2 ; call fib::fib %_4 = call i64 @_ZN3fib3fib17h03330887093d3356E ( i64 %_7.0 ) br label %bb4 panic: ; preds = %bb2 ; call core::panicking::panic call void @_ZN4core9panicking5panic17h2c89bafc52ad2c2fE ([ 0 x i8 ]* nonnull align 1 bitcast ([ 33 x i8 ]* @str.1 to [ 0 x i8 ]*), i64 33 , %\"std::panic::Location\" * align 8 dereferenceable ( 24 ) bitcast (<{ i8 *, [ 16 x i8 ] }>* @alloc38 to %\"std::panic::Location\" *)) unreachable bb4: ; preds = %bb3 %4 = call { i64 , i1 } @llvm.ssub.with.overflow.i64 ( i64 %n , i64 2 ) %_11.0 = extractvalue { i64 , i1 } %4 , 0 %_11.1 = extractvalue { i64 , i1 } %4 , 1 %5 = call i1 @llvm.expect.i1 ( i1 %_11.1 , i1 false ) br i1 %5 , label %panic1 , label %bb5 bb5: ; preds = %bb4 ; call fib::fib %_8 = call i64 @_ZN3fib3fib17h03330887093d3356E ( i64 %_11.0 ) br label %bb6 panic1: ; preds = %bb4 ; call core::panicking::panic call void @_ZN4core9panicking5panic17h2c89bafc52ad2c2fE ([ 0 x i8 ]* nonnull align 1 bitcast ([ 33 x i8 ]* @str.1 to [ 0 x i8 ]*), i64 33 , %\"std::panic::Location\" * align 8 dereferenceable ( 24 ) bitcast (<{ i8 *, [ 16 x i8 ] }>* @alloc40 to %\"std::panic::Location\" *)) unreachable bb6: ; preds = %bb5 %6 = call { i64 , i1 } @llvm.sadd.with.overflow.i64 ( i64 %_4 , i64 %_8 ) %_12.0 = extractvalue { i64 , i1 } %6 , 0 %_12.1 = extractvalue { i64 , i1 } %6 , 1 %7 = call i1 @llvm.expect.i1 ( i1 %_12.1 , i1 false ) br i1 %7 , label %panic2 , label %bb7 bb7: ; preds = %bb6 store i64 %_12.0 , i64 * %0 , align 8 br label %bb8 panic2: ; preds = %bb6 ; call core::panicking::panic call void @_ZN4core9panicking5panic17h2c89bafc52ad2c2fE ([ 0 x i8 ]* nonnull align 1 bitcast ([ 28 x i8 ]* @str.2 to [ 0 x i8 ]*), i64 28 , %\"std::panic::Location\" * align 8 dereferenceable ( 24 ) bitcast (<{ i8 *, [ 16 x i8 ] }>* @alloc42 to %\"std::panic::Location\" *)) unreachable } ; fib.ll define hidden swiftcc i64 @\"$s3fibAAyS2iF\" ( i64 %0 ) #0 { entry: %n.debug = alloca i64 , align 8 %1 = bitcast i64 * %n.debug to i8 * call void @llvm.memset.p0i8.i64 ( i8 * align 8 %1 , i8 0 , i64 8 , i1 false ) store i64 %0 , i64 * %n.debug , align 8 %2 = icmp slt i64 %0 , 2 br i1 %2 , label %3 , label %4 3: ; preds = %entry br label %22 4: ; preds = %entry %5 = call { i64 , i1 } @llvm.ssub.with.overflow.i64 ( i64 %0 , i64 1 ) %6 = extractvalue { i64 , i1 } %5 , 0 %7 = extractvalue { i64 , i1 } %5 , 1 %8 = call i1 @llvm.expect.i1 ( i1 %7 , i1 false ) br i1 %8 , label %24 , label %9 9: ; preds = %4 %10 = call swiftcc i64 @\"$s3fibAAyS2iF\" ( i64 %6 ) %11 = call { i64 , i1 } @llvm.ssub.with.overflow.i64 ( i64 %0 , i64 2 ) %12 = extractvalue { i64 , i1 } %11 , 0 %13 = extractvalue { i64 , i1 } %11 , 1 %14 = call i1 @llvm.expect.i1 ( i1 %13 , i1 false ) br i1 %14 , label %25 , label %15 15: ; preds = %9 %16 = call swiftcc i64 @\"$s3fibAAyS2iF\" ( i64 %12 ) %17 = call { i64 , i1 } @llvm.sadd.with.overflow.i64 ( i64 %10 , i64 %16 ) %18 = extractvalue { i64 , i1 } %17 , 0 %19 = extractvalue { i64 , i1 } %17 , 1 %20 = call i1 @llvm.expect.i1 ( i1 %19 , i1 false ) br i1 %20 , label %26 , label %21 21: ; preds = %15 br label %22 22: ; preds = %3, %21 %23 = phi i64 [ %18 , %21 ], [ %0 , %3 ] ret i64 %23 24: ; preds = %4 call void @llvm.trap () unreachable 25: ; preds = %9 call void @llvm.trap () unreachable 26: ; preds = %15 call void @llvm.trap () unreachable } Exercise Identify the Fibonacci function's base case and recursive call in the LLVM IR. 1.2 Inject instrumentation Pass fib.ll to spoor_opt to inject instrumentation into the IR. spoor_opt \\ fib.ll \\ --output_file = fib_instrumented.ll \\ --output_symbols_file = fib.spoor_symbols \\ --output_language = ir Spoor injects a call to _spoor_runtime_LogFunctionEntry at the start of every function and a call to _spoor_runtime_LogFunctionExit before each function return. C++ Rust Swift ; fib_instrumented.ll define dso_local i32 @_Z3Fibi(i32 %0) #0 { + call void @_spoor_runtime_LogFunctionEntry(i64 6838069263626928128) %2 = alloca i32, align 4 %3 = alloca i32, align 4 store i32 %0, i32* %3, align 4 %4 = load i32, i32* %3, align 4 %5 = icmp slt i32 %4, 2 br i1 %5, label %6, label %8 6: ; preds = %1 %7 = load i32, i32* %3, align 4 store i32 %7, i32* %2, align 4 br label %16 8: ; preds = %1 %9 = load i32, i32* %3, align 4 %10 = sub nsw i32 %9, 1 %11 = call i32 @_Z3Fibi(i32 %10) %12 = load i32, i32* %3, align 4 %13 = sub nsw i32 %12, 2 %14 = call i32 @_Z3Fibi(i32 %13) %15 = add nsw i32 %11, %14 store i32 %15, i32* %2, align 4 br label %16 16: ; preds = %8, %6 %17 = load i32, i32* %2, align 4 + call void @_spoor_runtime_LogFunctionExit(i64 6838069263626928128) ret i32 %17 } ; fib_instrumented.ll define internal i64 @_ZN3fib3fib17h03330887093d3356E(i64 %n) unnamed_addr #1 { start: + call void @_spoor_runtime_LogFunctionEntry(i64 1161011135638405136) %0 = alloca i64, align 8 %_2 = icmp slt i64 %n, 2 br i1 %_2, label %bb1, label %bb2 bb2: ; preds = %start %1 = call { i64, i1 } @llvm.ssub.with.overflow.i64(i64 %n, i64 1) %_7.0 = extractvalue { i64, i1 } %1, 0 %_7.1 = extractvalue { i64, i1 } %1, 1 %2 = call i1 @llvm.expect.i1(i1 %_7.1, i1 false) br i1 %2, label %panic, label %bb3 bb1: ; preds = %start store i64 %n, i64* %0, align 8 br label %bb8 bb8: ; preds = %bb7, %bb1 %3 = load i64, i64* %0, align 8 + call void @_spoor_runtime_LogFunctionExit(i64 1161011135638405136) ret i64 %3 bb3: ; preds = %bb2 %_4 = call i64 @_ZN3fib3fib17h03330887093d3356E(i64 %_7.0) br label %bb4 panic: ; preds = %bb2 call void @_ZN4core9panicking5panic17h2c89bafc52ad2c2fE([0 x i8]* nonnull align 1 bitcast ([33 x i8]* @str.1 to [0 x i8]*), i64 33, %\"std::panic::Location\"* align 8 dereferenceable(24) bitcast (<{ i8*, [16 x i8] }>* @alloc38 to %\"std::panic::Location\"*)) unreachable bb4: ; preds = %bb3 %4 = call { i64, i1 } @llvm.ssub.with.overflow.i64(i64 %n, i64 2) %_11.0 = extractvalue { i64, i1 } %4, 0 %_11.1 = extractvalue { i64, i1 } %4, 1 %5 = call i1 @llvm.expect.i1(i1 %_11.1, i1 false) br i1 %5, label %panic1, label %bb5 bb5: ; preds = %bb4 %_8 = call i64 @_ZN3fib3fib17h03330887093d3356E(i64 %_11.0) br label %bb6 panic1: ; preds = %bb4 call void @_ZN4core9panicking5panic17h2c89bafc52ad2c2fE([0 x i8]* nonnull align 1 bitcast ([33 x i8]* @str.1 to [0 x i8]*), i64 33, %\"std::panic::Location\"* align 8 dereferenceable(24) bitcast (<{ i8*, [16 x i8] }>* @alloc40 to %\"std::panic::Location\"*)) unreachable bb6: ; preds = %bb5 %6 = call { i64, i1 } @llvm.sadd.with.overflow.i64(i64 %_4, i64 %_8) %_12.0 = extractvalue { i64, i1 } %6, 0 %_12.1 = extractvalue { i64, i1 } %6, 1 %7 = call i1 @llvm.expect.i1(i1 %_12.1, i1 false) br i1 %7, label %panic2, label %bb7 bb7: ; preds = %bb6 store i64 %_12.0, i64* %0, align 8 br label %bb8 panic2: ; preds = %bb6 call void @_ZN4core9panicking5panic17h2c89bafc52ad2c2fE([0 x i8]* nonnull align 1 bitcast ([28 x i8]* @str.2 to [0 x i8]*), i64 28, %\"std::panic::Location\"* align 8 dereferenceable(24) bitcast (<{ i8*, [16 x i8] }>* @alloc42 to %\"std::panic::Location\"*)) unreachable } define hidden swiftcc i64 @\"$s3fibAAyS2iF\"(i64 %0) #0 { entry: + call void @_spoor_runtime_LogFunctionEntry(i64 -5425404140006146047) %n.debug = alloca i64, align 8 %1 = bitcast i64* %n.debug to i8* call void @llvm.memset.p0i8.i64(i8* align 8 %1, i8 0, i64 8, i1 false) store i64 %0, i64* %n.debug, align 8 %2 = icmp slt i64 %0, 2 br i1 %2, label %3, label %4 3: ; preds = %entry br label %22 4: ; preds = %entry %5 = call { i64, i1 } @llvm.ssub.with.overflow.i64(i64 %0, i64 1) %6 = extractvalue { i64, i1 } %5, 0 %7 = extractvalue { i64, i1 } %5, 1 %8 = call i1 @llvm.expect.i1(i1 %7, i1 false) br i1 %8, label %24, label %9 9: ; preds = %4 %10 = call swiftcc i64 @\"$s3fibAAyS2iF\"(i64 %6) %11 = call { i64, i1 } @llvm.ssub.with.overflow.i64(i64 %0, i64 2) %12 = extractvalue { i64, i1 } %11, 0 %13 = extractvalue { i64, i1 } %11, 1 %14 = call i1 @llvm.expect.i1(i1 %13, i1 false) br i1 %14, label %25, label %15 15: ; preds = %9 %16 = call swiftcc i64 @\"$s3fibAAyS2iF\"(i64 %12) %17 = call { i64, i1 } @llvm.sadd.with.overflow.i64(i64 %10, i64 %16) %18 = extractvalue { i64, i1 } %17, 0 %19 = extractvalue { i64, i1 } %17, 1 %20 = call i1 @llvm.expect.i1(i1 %19, i1 false) br i1 %20, label %26, label %21 21: ; preds = %15 br label %22 22: ; preds = %21, %3 %23 = phi i64 [ %18, %21 ], [ %0, %3 ] + call void @_spoor_runtime_LogFunctionExit(i64 -5425404140006146047) ret i64 %23 24: ; preds = %4 call void @llvm.trap() unreachable 25: ; preds = %9 call void @llvm.trap() unreachable 26: ; preds = %15 call void @llvm.trap() unreachable } Additionally, Spoor automatically initializes and enables the runtime in main . This behavior is configurable . C++ Rust Swift ; fib_instrumented.ll define dso_local i32 @main() #1 { + call void @_spoor_runtime_Initialize() + call void @_spoor_runtime_Enable() + call void @_spoor_runtime_LogFunctionEntry(i64 6838069263626928129) %1 = alloca i32, align 4 %2 = alloca i32, align 4 store i32 10, i32* %1, align 4 %3 = call i32 @_Z3Fibi(i32 10) store i32 %3, i32* %2, align 4 %4 = load i32, i32* %2, align 4 %5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str, i64 0, i64 0), i32 10, i32 %4) + call void @_spoor_runtime_LogFunctionExit(i64 6838069263626928129) + call void @_spoor_runtime_Deinitialize() ret i32 0 } ; fib_instrumented.ll define i32 @main(i32 %0, i8** %1) unnamed_addr #9 { + call void @_spoor_runtime_Initialize() + call void @_spoor_runtime_Enable() + call void @_spoor_runtime_LogFunctionEntry(i64 1161011135638405138) %2 = sext i32 %0 to i64 %3 = call i64 @_ZN3std2rt10lang_start17h11fbc72de187ccfcE(void ()* @_ZN3fib4main17h169520592592741fE, i64 %2, i8** %1) %4 = trunc i64 %3 to i32 + call void @_spoor_runtime_LogFunctionExit(i64 1161011135638405138) + call void @_spoor_runtime_Deinitialize() ret i32 %4 } ; fib_instrumented.ll define i32 @main(i32 %0, i8** %1) #0 { entry: + call void @_spoor_runtime_Initialize() + call void @_spoor_runtime_Enable() + call void @_spoor_runtime_LogFunctionEntry(i64 -5425404140006146048) %2 = alloca %Ts26DefaultStringInterpolationV, align 8 %3 = bitcast %Ts26DefaultStringInterpolationV* %2 to i8* call void @llvm.memset.p0i8.i64(i8* align 8 %3, i8 0, i64 16, i1 false) %4 = alloca %TSi, align 8 %5 = alloca %TSi, align 8 %6 = bitcast i8** %1 to i8* store i64 10, i64* getelementptr inbounds (%TSi, %TSi* @\"$s3fib1nSivp\", i32 0, i32 0), align 8 %7 = load i64, i64* getelementptr inbounds (%TSi, %TSi* @\"$s3fib1nSivp\", i32 0, i32 0), align 8 %8 = call swiftcc i64 @\"$s3fibAAyS2iF\"(i64 %7) store i64 %8, i64* getelementptr inbounds (%TSi, %TSi* @\"$s3fib1fSivp\", i32 0, i32 0), align 8 %9 = call swiftcc { %swift.bridge*, i8* } @\"$ss27_allocateUninitializedArrayySayxG_BptBwlF\"(i64 1, %swift.type* getelementptr inbounds (%swift.full_type, %swift.full_type* @\"$sypN\", i32 0, i32 1)) %10 = extractvalue { %swift.bridge*, i8* } %9, 0 %11 = extractvalue { %swift.bridge*, i8* } %9, 1 %12 = bitcast i8* %11 to %Any* %13 = bitcast %Ts26DefaultStringInterpolationV* %2 to i8* call void @llvm.lifetime.start.p0i8(i64 16, i8* %13) %14 = call swiftcc { i64, %swift.bridge* } @\"$ss26DefaultStringInterpolationV15literalCapacity18interpolationCountABSi_SitcfC\"(i64 8, i64 2) %15 = extractvalue { i64, %swift.bridge* } %14, 0 %16 = extractvalue { i64, %swift.bridge* } %14, 1 %._storage = getelementptr inbounds %Ts26DefaultStringInterpolationV, %Ts26DefaultStringInterpolationV* %2, i32 0, i32 0 %._storage._guts = getelementptr inbounds %TSS, %TSS* %._storage, i32 0, i32 0 %._storage._guts._object = getelementptr inbounds %Ts11_StringGutsV, %Ts11_StringGutsV* %._storage._guts, i32 0, i32 0 %._storage._guts._object._countAndFlagsBits = getelementptr inbounds %Ts13_StringObjectV, %Ts13_StringObjectV* %._storage._guts._object, i32 0, i32 0 %._storage._guts._object._countAndFlagsBits._value = getelementptr inbounds %Ts6UInt64V, %Ts6UInt64V* %._storage._guts._object._countAndFlagsBits, i32 0, i32 0 store i64 %15, i64* %._storage._guts._object._countAndFlagsBits._value, align 8 %._storage._guts._object._object = getelementptr inbounds %Ts13_StringObjectV, %Ts13_StringObjectV* %._storage._guts._object, i32 0, i32 1 store %swift.bridge* %16, %swift.bridge** %._storage._guts._object._object, align 8 %17 = call swiftcc { i64, %swift.bridge* } @\"$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC\"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @0, i64 0, i64 0), i64 4, i1 true) %18 = extractvalue { i64, %swift.bridge* } %17, 0 %19 = extractvalue { i64, %swift.bridge* } %17, 1 call swiftcc void @\"$ss26DefaultStringInterpolationV13appendLiteralyySSF\"(i64 %18, %swift.bridge* %19, %Ts26DefaultStringInterpolationV* nocapture swiftself dereferenceable(16) %2) call void @swift_bridgeObjectRelease(%swift.bridge* %19) #3 %20 = load i64, i64* getelementptr inbounds (%TSi, %TSi* @\"$s3fib1nSivp\", i32 0, i32 0), align 8 %21 = bitcast %TSi* %4 to i8* call void @llvm.lifetime.start.p0i8(i64 8, i8* %21) %._value = getelementptr inbounds %TSi, %TSi* %4, i32 0, i32 0 store i64 %20, i64* %._value, align 8 %22 = bitcast %TSi* %4 to %swift.opaque* call swiftcc void @\"$ss26DefaultStringInterpolationV06appendC0yyxs06CustomB11ConvertibleRzlF\"(%swift.opaque* noalias nocapture %22, %swift.type* @\"$sSiN\", i8** @\"$sSis23CustomStringConvertiblesWP\", %Ts26DefaultStringInterpolationV* nocapture swiftself dereferenceable(16) %2) %23 = bitcast %TSi* %4 to i8* call void @llvm.lifetime.end.p0i8(i64 8, i8* %23) %24 = call swiftcc { i64, %swift.bridge* } @\"$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC\"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @1, i64 0, i64 0), i64 4, i1 true) %25 = extractvalue { i64, %swift.bridge* } %24, 0 %26 = extractvalue { i64, %swift.bridge* } %24, 1 call swiftcc void @\"$ss26DefaultStringInterpolationV13appendLiteralyySSF\"(i64 %25, %swift.bridge* %26, %Ts26DefaultStringInterpolationV* nocapture swiftself dereferenceable(16) %2) call void @swift_bridgeObjectRelease(%swift.bridge* %26) #3 %27 = load i64, i64* getelementptr inbounds (%TSi, %TSi* @\"$s3fib1fSivp\", i32 0, i32 0), align 8 %28 = bitcast %TSi* %5 to i8* call void @llvm.lifetime.start.p0i8(i64 8, i8* %28) %._value1 = getelementptr inbounds %TSi, %TSi* %5, i32 0, i32 0 store i64 %27, i64* %._value1, align 8 %29 = bitcast %TSi* %5 to %swift.opaque* call swiftcc void @\"$ss26DefaultStringInterpolationV06appendC0yyxs06CustomB11ConvertibleRzlF\"(%swift.opaque* noalias nocapture %29, %swift.type* @\"$sSiN\", i8** @\"$sSis23CustomStringConvertiblesWP\", %Ts26DefaultStringInterpolationV* nocapture swiftself dereferenceable(16) %2) %30 = bitcast %TSi* %5 to i8* call void @llvm.lifetime.end.p0i8(i64 8, i8* %30) %31 = call swiftcc { i64, %swift.bridge* } @\"$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC\"(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @2, i64 0, i64 0), i64 0, i1 true) %32 = extractvalue { i64, %swift.bridge* } %31, 0 %33 = extractvalue { i64, %swift.bridge* } %31, 1 call swiftcc void @\"$ss26DefaultStringInterpolationV13appendLiteralyySSF\"(i64 %32, %swift.bridge* %33, %Ts26DefaultStringInterpolationV* nocapture swiftself dereferenceable(16) %2) call void @swift_bridgeObjectRelease(%swift.bridge* %33) #3 %._storage2 = getelementptr inbounds %Ts26DefaultStringInterpolationV, %Ts26DefaultStringInterpolationV* %2, i32 0, i32 0 %._storage2._guts = getelementptr inbounds %TSS, %TSS* %._storage2, i32 0, i32 0 %._storage2._guts._object = getelementptr inbounds %Ts11_StringGutsV, %Ts11_StringGutsV* %._storage2._guts, i32 0, i32 0 %._storage2._guts._object._countAndFlagsBits = getelementptr inbounds %Ts13_StringObjectV, %Ts13_StringObjectV* %._storage2._guts._object, i32 0, i32 0 %._storage2._guts._object._countAndFlagsBits._value = getelementptr inbounds %Ts6UInt64V, %Ts6UInt64V* %._storage2._guts._object._countAndFlagsBits, i32 0, i32 0 %34 = load i64, i64* %._storage2._guts._object._countAndFlagsBits._value, align 8 %._storage2._guts._object._object = getelementptr inbounds %Ts13_StringObjectV, %Ts13_StringObjectV* %._storage2._guts._object, i32 0, i32 1 %35 = load %swift.bridge*, %swift.bridge** %._storage2._guts._object._object, align 8 %36 = call %swift.bridge* @swift_bridgeObjectRetain(%swift.bridge* returned %35) #3 %37 = call %Ts26DefaultStringInterpolationV* @\"$ss26DefaultStringInterpolationVWOh\"(%Ts26DefaultStringInterpolationV* %2) %38 = bitcast %Ts26DefaultStringInterpolationV* %2 to i8* call void @llvm.lifetime.end.p0i8(i64 16, i8* %38) %39 = call swiftcc { i64, %swift.bridge* } @\"$sSS19stringInterpolationSSs013DefaultStringB0V_tcfC\"(i64 %34, %swift.bridge* %35) %40 = extractvalue { i64, %swift.bridge* } %39, 0 %41 = extractvalue { i64, %swift.bridge* } %39, 1 %42 = getelementptr inbounds %Any, %Any* %12, i32 0, i32 1 store %swift.type* @\"$sSSN\", %swift.type** %42, align 8 %43 = getelementptr inbounds %Any, %Any* %12, i32 0, i32 0 %44 = getelementptr inbounds %Any, %Any* %12, i32 0, i32 0 %45 = bitcast [24 x i8]* %44 to %TSS* %._guts = getelementptr inbounds %TSS, %TSS* %45, i32 0, i32 0 %._guts._object = getelementptr inbounds %Ts11_StringGutsV, %Ts11_StringGutsV* %._guts, i32 0, i32 0 %._guts._object._countAndFlagsBits = getelementptr inbounds %Ts13_StringObjectV, %Ts13_StringObjectV* %._guts._object, i32 0, i32 0 %._guts._object._countAndFlagsBits._value = getelementptr inbounds %Ts6UInt64V, %Ts6UInt64V* %._guts._object._countAndFlagsBits, i32 0, i32 0 store i64 %40, i64* %._guts._object._countAndFlagsBits._value, align 8 %._guts._object._object = getelementptr inbounds %Ts13_StringObjectV, %Ts13_StringObjectV* %._guts._object, i32 0, i32 1 store %swift.bridge* %41, %swift.bridge** %._guts._object._object, align 8 %46 = call swiftcc %swift.bridge* @\"$ss27_finalizeUninitializedArrayySayxGABnlF\"(%swift.bridge* %10, %swift.type* getelementptr inbounds (%swift.full_type, %swift.full_type* @\"$sypN\", i32 0, i32 1)) %47 = call swiftcc { i64, %swift.bridge* } @\"$ss5print_9separator10terminatoryypd_S2StFfA0_\"() %48 = extractvalue { i64, %swift.bridge* } %47, 0 %49 = extractvalue { i64, %swift.bridge* } %47, 1 %50 = call swiftcc { i64, %swift.bridge* } @\"$ss5print_9separator10terminatoryypd_S2StFfA1_\"() %51 = extractvalue { i64, %swift.bridge* } %50, 0 %52 = extractvalue { i64, %swift.bridge* } %50, 1 call swiftcc void @\"$ss5print_9separator10terminatoryypd_S2StF\"(%swift.bridge* %46, i64 %48, %swift.bridge* %49, i64 %51, %swift.bridge* %52) call void @swift_bridgeObjectRelease(%swift.bridge* %52) #3 call void @swift_bridgeObjectRelease(%swift.bridge* %49) #3 call void @swift_bridgeObjectRelease(%swift.bridge* %46) #3 + call void @_spoor_runtime_LogFunctionExit(i64 -5425404140006146048) + call void @_spoor_runtime_Deinitialize() ret i32 0 } Each call to LogFunctionEntry and LogFunctionExit contains a single numeric argument. This number uniquely identifies the function in your program and is logged in the trace at runtime. fib.spoor_symbols maps these numbers to debug data to symbolize the trace offline. The easiest way to inspect the symbols file is by converting it to a csv . spoor fib.spoor_symbols --output_file = fib_symbols.csv C++ Rust Swift Function ID Linkage name Demangled name 0x5ee5b3c400000000 _Z3Fibi Fib(int) 0x5ee5b3c400000001 main main Function ID Linkage name Demangled name 0x101cbd7a00001300 _ZN3fib3fib17h03330887093d3356E fib::fib::h03330887093d3356 0x101cbd7a00001300 _zn3fib4main17h169520592592741fE fib::main::h169520592592741f 0x101cbd7a00001300 main main Function ID Linkage name Demangled name 0xb4b517ae00000000 main main 0xb4b517ae00000001 $s3fibAAyS2iF fib.fib(Swift.Int) -> Swift.Int 2. Compile and run 2.1 Compile the IR Compile the instrumented IR using clang++ and link in the runtime library. The runtime library is responsible for efficiently handling incoming instrumentation events (e.g., function entries and exists) by buffering them in-memory and flushing them to disk. C++ Rust Swift clang++ \\ fib_instrumented.ll \\ -o fib_instrumented \\ -L/path/to/spoor/libraries \\ -lspoor_runtime \\ -lspoor_runtime_default_config clang++ \\ fib_instrumented.ll \\ -o fib_instrumented \\ -L/path/to/spoor/libraries \\ -lspoor_runtime \\ -lspoor_runtime_default_config \\ -L/path/to/.rustup/toolchains/stable-target/lib \\ -lstd-xxxxxxxxxxxxxxxx \\ -Wl,-rpath,/path/to/.rustup/toolchains/stable-target/lib clang++ \\ fib_instrumented.ll \\ -o fib_instrumented \\ -L/path/to/libspoor_runtime \\ -lspoor_runtime \\ -lspoor_runtime_default_config \\ -L/usr/lib/swift 2.2 Run the instrumented binary Run the instrumented binary. ./fib_instrumented Your program prints the tenth Fibonacci number to stdout as before. Fib(10) = 55 Additionally, your program emits one or more binary .spoor_trace files which efficiently store the trace data for that execution. By default, Spoor's runtime saves trace files in the current directory. find . -name \"*.spoor_trace\" xxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx.spoor_trace 3. Process and analyze the trace Finally, parse and symbolize the trace data to view it in Perfetto's trace viewer . 3.1 Parse and symbolize the trace Use spoor , Spoor's postprocessing tool, to parse the .spoor_trace file(s), symbolize the trace with the .spoor_symbols file(s), and output a Perfetto-compatible trace. spoor \\ xxxxxxxxxxxxxxxx-yyyyyyyyyyyyyyyy-zzzzzzzzzzzzzzzz.spoor_trace \\ fib.spoor_symbols \\ --output_file = fib.perfetto 3.2 Visualize the trace Open fib.perfetto in ui.perfetto.dev , Perfetto's trace viewer. The flame graph timeline visualization shows the stack trace of your program over time. Notice the tree-like structure formed by the exponential calls. C++ Rust Swift 3.3 Query the trace Perfetto's supports querying the trace with SQL. What data does the slice table contain? SELECT * FROM slice ; id type ts dur track_id category name depth stack_id parent_stack_id parent_id arg_set_id cat slice_id 0 thread_slice 1634680417099962600 264152 0 NULL main 0 6833849221975760 0 NULL 2 NULL 1 thread_slice 1634680417100002800 194521 0 NULL Fib(int) 1 1089519434040343 6833849221975760 0 3 NULL 1 2 thread_slice 1634680417100003600 130467 0 NULL Fib(int) 2 1009479496053168 1089519434040343 1 3 NULL 2 How many times was Fib called? SELECT COUNT ( * ) FROM slice WHERE name LIKE 'fib%' ; 177 What's the deepest stack? SELECT MAX ( depth ) FROM slice WHERE name LIKE 'fib%' ; 10 Going further The time complexity of this Fibonacci implementation is exponential \u2013 a suboptimal algorithm. Optimize the runtime of your Fibonacci program by caching already-computed values (i.e., dynamic programming), instrument your new code, and visualize the trace with Perfetto. Closed-form solution There's an even more optimal, closed-form, constant-time solution, but a single function call doesn't look very interesting in the trace. \\[ F_n = \\frac{\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n - \\left(\\frac{1 - \\sqrt{5}}{2}\\right)^n}{\\sqrt{5}} \\] Optimize the code C++ Rust Swift // fib.cc #include <cstdio> #include <unordered_map> auto Fib ( const int n , std :: unordered_map < int , int >* cache ) -> int { if ( n < 2 ) return n ; if ( cache -> find ( n ) != cache -> cend ()) return cache -> at ( n ); const auto result = Fib ( n - 1 , cache ) + Fib ( n - 2 , cache ); cache -> emplace ( n , result ); return result ; } auto main () -> int { constexpr auto n = 10 ; std :: unordered_map < int , int > cache {}; const auto f = Fib ( n , & cache ); printf ( \"Fib(%d) = %d \\n \" , n , f ); } // fib.rs use std :: collections :: HashMap ; fn fib ( n : i64 , cache : & mut HashMap < i64 , i64 > ) -> i64 { if n < 2 { return n ; } if let Some ( result ) = cache . get ( & n ) { return * result } let result = fib ( n - 1 , cache ) + fib ( n - 2 , cache ); cache . insert ( n , result ); return result } pub fn main () { let n = 10 ; let mut cache = HashMap :: new (); let f = fib ( n , & mut cache ); println! ( \"Fib({}) = {}\" , n , f ); } // fib.swift import Foundation func fib ( _ n : Int , _ cache : inout [ Int : Int ]) -> Int { if n < 2 { return n } if let result = cache [ n ] { return result } let result = fib ( n - 1 , & cache ) + fib ( n - 2 , & cache ) cache [ n ] = result return result } let n = 10 var cache = [ Int : Int ]() let f = fib ( n , & cache ) print ( \"Fib( \\( n ) ) = \\( f ) \" ) Visualize the optimized code C++ Rust Swift By default, Spoor instruments all source code it compiles from source. This includes C++'s (header-only) standard template library but not Swift's (precompiled) Foundations library. Therefore, calls to C++'s std::unordered_map appear in the trace but calls to Swift's Dictionary do not. Filters file Filter unwanted functions from the trace by configuring spoor_opt with a filters file . Query the optimized code How many times was Fib called? SELECT COUNT ( * ) FROM slice WHERE name LIKE 'fib%' ; 19 Recall that original implementation (without caching) made 177 function calls to Fib \u2013 strong evidence that caching reduced unnecessary recursive calls. What's the deepest stack? SELECT MAX ( depth ) FROM slice WHERE name LIKE 'fib%' ; 10 Conclusion Spoor is a toolchain to instrumented source code, efficiently handle incoming events, and parse the generated trace files for offline analysis using tools such as Perfetto's visualizer.","title":"Fibonacci"},{"location":"tutorials/fibonacci/#fibonacci","text":"This tutorial uses Spoor to instrument a program that calculates Fibonacci numbers . You'll learn Spoor's pipeline to automatically inject instrumentation into your source code, build and run your Spoor-instrumented program, symbolize the trace, and visualize and analyze your symbolized trace using Perfetto.","title":"Fibonacci"},{"location":"tutorials/fibonacci/#0-prerequisites","text":"","title":"0. Prerequisites"},{"location":"tutorials/fibonacci/#01-setup-and-dependencies","text":"You will need: Spoor's toolchain including spoor_opt : Compiler instrumentation libspoor_runtime.a : Runtime library libspoor_runtime_default_config.a : Runtime library default configuration spoor : Postprocessing tool clang++ , rustc , swiftc , or another LLVM-based compiler of your choice. clang++ to assemble the IR and link in the standard library. A hop, a skip, and a can-do attitude. Version This tutorial uses the following tools. Your mileage may vary with newer or older versions. spoor_opt spoor_opt --version spoor_opt 0.0.0 Based on LLVM 13.0.1 libspoor_runtime 0.0.0 spoor spoor --version spoor 0.0.0 clang++ clang++ version clang version 12.0.1 C++ Rust Swift clang++ version clang version 12.0.1 rustc --version rustc 1.55.0 swiftc --version swift-driver version: 1.26.9 Apple Swift version 5.5","title":"0.1 Setup and dependencies"},{"location":"tutorials/fibonacci/#02-write-your-code","text":"The Fibonacci numbers, denoted \\(F_n\\) , form a sequence where each number is the sum of the two preceding ones, starting from 0 and 1. That is, \\[ \\begin{align} F_0 &= 0 \\\\ F_1 &= 1 \\\\ F_n &= F_{n-1} + F_{n-2}, \\quad n > 1 \\end{align} \\] \\[ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \\ldots \\] This recursive definition can be implemented as follows: C++ Rust Swift // fib.cc #include <cstdio> auto Fib ( const int n ) -> int { if ( n < 2 ) return n ; return Fib ( n - 1 ) + Fib ( n - 2 ); } auto main () -> int { constexpr auto n = 46 ; const auto f = Fib ( n ); printf ( \"Fib(%d) = %d \\n \" , n , f ); } // fib.rs fn fib ( n : i64 ) -> i64 { if n < 2 { return n ; } return fib ( n - 1 ) + fib ( n - 2 ) } fn main () { let n = 10 ; let f = fib ( n ); println! ( \"Fib({}) = {}\" , n , f ); } // fib.swift import Foundation func fib ( _ n : Int ) -> Int { if n < 2 { return n } return fib ( n - 1 ) + fib ( n - 2 ) } let n = 10 let f = fib ( n ) print ( \"Fib( \\( n ) ) = \\( f ) \" ) Sanity test Build and run your (uninstrumented) code to make sure that everything works as expected. C++ Rust Swift clang++ fib.cc -o fib && ./fib rustc fib.rs && ./fib swiftc fib.swift && ./fib Fib(10) = 55","title":"0.2 Write your code"},{"location":"tutorials/fibonacci/#1-instrument-your-code","text":"Spoor works by instrumenting LLVM IR , a common intermediate representation between your high-level source code and machine code for LLVM-based languages.","title":"1. Instrument your code"},{"location":"tutorials/fibonacci/#11-emit-ir","text":"Emit LLVM IR instead of compiling down to an object file. C++ Rust Swift clang++ fib.cc -emit-llvm -S -o fib.ll rustc fib.rs --emit llvm-ir -o fib.ll swiftc fib.swift -emit-ir -o fib.ll Debug data Compile with debug data ( -g ) to include the source file and line number in the symbolized trace. Inspect the file fib.ll to view the (uninstrumented) IR. Each language's emitted IR is different due to the nature of the source language and its compiler frontend, but they are all functionally equivalent. C++ Rust Swift ; fib.ll define dso_local i32 @_Z3Fibi ( i32 %0 ) #0 { %2 = alloca i32 , align 4 %3 = alloca i32 , align 4 store i32 %0 , i32 * %3 , align 4 %4 = load i32 , i32 * %3 , align 4 %5 = icmp slt i32 %4 , 2 br i1 %5 , label %6 , label %8 6: ; preds = %1 %7 = load i32 , i32 * %3 , align 4 store i32 %7 , i32 * %2 , align 4 br label %16 8: ; preds = %1 %9 = load i32 , i32 * %3 , align 4 %10 = sub nsw i32 %9 , 1 %11 = call i32 @_Z3Fibi ( i32 %10 ) %12 = load i32 , i32 * %3 , align 4 %13 = sub nsw i32 %12 , 2 %14 = call i32 @_Z3Fibi ( i32 %13 ) %15 = add nsw i32 %11 , %14 store i32 %15 , i32 * %2 , align 4 br label %16 16: ; preds = %8, %6 %17 = load i32 , i32 * %2 , align 4 ret i32 %17 } ; fib.ll define internal i64 @_ZN3fib3fib17h03330887093d3356E ( i64 %n ) unnamed_addr #1 { start: %0 = alloca i64 , align 8 %_2 = icmp slt i64 %n , 2 br i1 %_2 , label %bb1 , label %bb2 bb2: ; preds = %start %1 = call { i64 , i1 } @llvm.ssub.with.overflow.i64 ( i64 %n , i64 1 ) %_7.0 = extractvalue { i64 , i1 } %1 , 0 %_7.1 = extractvalue { i64 , i1 } %1 , 1 %2 = call i1 @llvm.expect.i1 ( i1 %_7.1 , i1 false ) br i1 %2 , label %panic , label %bb3 bb1: ; preds = %start store i64 %n , i64 * %0 , align 8 br label %bb8 bb8: ; preds = %bb7, %bb1 %3 = load i64 , i64 * %0 , align 8 ret i64 %3 bb3: ; preds = %bb2 ; call fib::fib %_4 = call i64 @_ZN3fib3fib17h03330887093d3356E ( i64 %_7.0 ) br label %bb4 panic: ; preds = %bb2 ; call core::panicking::panic call void @_ZN4core9panicking5panic17h2c89bafc52ad2c2fE ([ 0 x i8 ]* nonnull align 1 bitcast ([ 33 x i8 ]* @str.1 to [ 0 x i8 ]*), i64 33 , %\"std::panic::Location\" * align 8 dereferenceable ( 24 ) bitcast (<{ i8 *, [ 16 x i8 ] }>* @alloc38 to %\"std::panic::Location\" *)) unreachable bb4: ; preds = %bb3 %4 = call { i64 , i1 } @llvm.ssub.with.overflow.i64 ( i64 %n , i64 2 ) %_11.0 = extractvalue { i64 , i1 } %4 , 0 %_11.1 = extractvalue { i64 , i1 } %4 , 1 %5 = call i1 @llvm.expect.i1 ( i1 %_11.1 , i1 false ) br i1 %5 , label %panic1 , label %bb5 bb5: ; preds = %bb4 ; call fib::fib %_8 = call i64 @_ZN3fib3fib17h03330887093d3356E ( i64 %_11.0 ) br label %bb6 panic1: ; preds = %bb4 ; call core::panicking::panic call void @_ZN4core9panicking5panic17h2c89bafc52ad2c2fE ([ 0 x i8 ]* nonnull align 1 bitcast ([ 33 x i8 ]* @str.1 to [ 0 x i8 ]*), i64 33 , %\"std::panic::Location\" * align 8 dereferenceable ( 24 ) bitcast (<{ i8 *, [ 16 x i8 ] }>* @alloc40 to %\"std::panic::Location\" *)) unreachable bb6: ; preds = %bb5 %6 = call { i64 , i1 } @llvm.sadd.with.overflow.i64 ( i64 %_4 , i64 %_8 ) %_12.0 = extractvalue { i64 , i1 } %6 , 0 %_12.1 = extractvalue { i64 , i1 } %6 , 1 %7 = call i1 @llvm.expect.i1 ( i1 %_12.1 , i1 false ) br i1 %7 , label %panic2 , label %bb7 bb7: ; preds = %bb6 store i64 %_12.0 , i64 * %0 , align 8 br label %bb8 panic2: ; preds = %bb6 ; call core::panicking::panic call void @_ZN4core9panicking5panic17h2c89bafc52ad2c2fE ([ 0 x i8 ]* nonnull align 1 bitcast ([ 28 x i8 ]* @str.2 to [ 0 x i8 ]*), i64 28 , %\"std::panic::Location\" * align 8 dereferenceable ( 24 ) bitcast (<{ i8 *, [ 16 x i8 ] }>* @alloc42 to %\"std::panic::Location\" *)) unreachable } ; fib.ll define hidden swiftcc i64 @\"$s3fibAAyS2iF\" ( i64 %0 ) #0 { entry: %n.debug = alloca i64 , align 8 %1 = bitcast i64 * %n.debug to i8 * call void @llvm.memset.p0i8.i64 ( i8 * align 8 %1 , i8 0 , i64 8 , i1 false ) store i64 %0 , i64 * %n.debug , align 8 %2 = icmp slt i64 %0 , 2 br i1 %2 , label %3 , label %4 3: ; preds = %entry br label %22 4: ; preds = %entry %5 = call { i64 , i1 } @llvm.ssub.with.overflow.i64 ( i64 %0 , i64 1 ) %6 = extractvalue { i64 , i1 } %5 , 0 %7 = extractvalue { i64 , i1 } %5 , 1 %8 = call i1 @llvm.expect.i1 ( i1 %7 , i1 false ) br i1 %8 , label %24 , label %9 9: ; preds = %4 %10 = call swiftcc i64 @\"$s3fibAAyS2iF\" ( i64 %6 ) %11 = call { i64 , i1 } @llvm.ssub.with.overflow.i64 ( i64 %0 , i64 2 ) %12 = extractvalue { i64 , i1 } %11 , 0 %13 = extractvalue { i64 , i1 } %11 , 1 %14 = call i1 @llvm.expect.i1 ( i1 %13 , i1 false ) br i1 %14 , label %25 , label %15 15: ; preds = %9 %16 = call swiftcc i64 @\"$s3fibAAyS2iF\" ( i64 %12 ) %17 = call { i64 , i1 } @llvm.sadd.with.overflow.i64 ( i64 %10 , i64 %16 ) %18 = extractvalue { i64 , i1 } %17 , 0 %19 = extractvalue { i64 , i1 } %17 , 1 %20 = call i1 @llvm.expect.i1 ( i1 %19 , i1 false ) br i1 %20 , label %26 , label %21 21: ; preds = %15 br label %22 22: ; preds = %3, %21 %23 = phi i64 [ %18 , %21 ], [ %0 , %3 ] ret i64 %23 24: ; preds = %4 call void @llvm.trap () unreachable 25: ; preds = %9 call void @llvm.trap () unreachable 26: ; preds = %15 call void @llvm.trap () unreachable } Exercise Identify the Fibonacci function's base case and recursive call in the LLVM IR.","title":"1.1 Emit IR"},{"location":"tutorials/fibonacci/#12-inject-instrumentation","text":"Pass fib.ll to spoor_opt to inject instrumentation into the IR. spoor_opt \\ fib.ll \\ --output_file = fib_instrumented.ll \\ --output_symbols_file = fib.spoor_symbols \\ --output_language = ir Spoor injects a call to _spoor_runtime_LogFunctionEntry at the start of every function and a call to _spoor_runtime_LogFunctionExit before each function return. C++ Rust Swift ; fib_instrumented.ll define dso_local i32 @_Z3Fibi(i32 %0) #0 { + call void @_spoor_runtime_LogFunctionEntry(i64 6838069263626928128) %2 = alloca i32, align 4 %3 = alloca i32, align 4 store i32 %0, i32* %3, align 4 %4 = load i32, i32* %3, align 4 %5 = icmp slt i32 %4, 2 br i1 %5, label %6, label %8 6: ; preds = %1 %7 = load i32, i32* %3, align 4 store i32 %7, i32* %2, align 4 br label %16 8: ; preds = %1 %9 = load i32, i32* %3, align 4 %10 = sub nsw i32 %9, 1 %11 = call i32 @_Z3Fibi(i32 %10) %12 = load i32, i32* %3, align 4 %13 = sub nsw i32 %12, 2 %14 = call i32 @_Z3Fibi(i32 %13) %15 = add nsw i32 %11, %14 store i32 %15, i32* %2, align 4 br label %16 16: ; preds = %8, %6 %17 = load i32, i32* %2, align 4 + call void @_spoor_runtime_LogFunctionExit(i64 6838069263626928128) ret i32 %17 } ; fib_instrumented.ll define internal i64 @_ZN3fib3fib17h03330887093d3356E(i64 %n) unnamed_addr #1 { start: + call void @_spoor_runtime_LogFunctionEntry(i64 1161011135638405136) %0 = alloca i64, align 8 %_2 = icmp slt i64 %n, 2 br i1 %_2, label %bb1, label %bb2 bb2: ; preds = %start %1 = call { i64, i1 } @llvm.ssub.with.overflow.i64(i64 %n, i64 1) %_7.0 = extractvalue { i64, i1 } %1, 0 %_7.1 = extractvalue { i64, i1 } %1, 1 %2 = call i1 @llvm.expect.i1(i1 %_7.1, i1 false) br i1 %2, label %panic, label %bb3 bb1: ; preds = %start store i64 %n, i64* %0, align 8 br label %bb8 bb8: ; preds = %bb7, %bb1 %3 = load i64, i64* %0, align 8 + call void @_spoor_runtime_LogFunctionExit(i64 1161011135638405136) ret i64 %3 bb3: ; preds = %bb2 %_4 = call i64 @_ZN3fib3fib17h03330887093d3356E(i64 %_7.0) br label %bb4 panic: ; preds = %bb2 call void @_ZN4core9panicking5panic17h2c89bafc52ad2c2fE([0 x i8]* nonnull align 1 bitcast ([33 x i8]* @str.1 to [0 x i8]*), i64 33, %\"std::panic::Location\"* align 8 dereferenceable(24) bitcast (<{ i8*, [16 x i8] }>* @alloc38 to %\"std::panic::Location\"*)) unreachable bb4: ; preds = %bb3 %4 = call { i64, i1 } @llvm.ssub.with.overflow.i64(i64 %n, i64 2) %_11.0 = extractvalue { i64, i1 } %4, 0 %_11.1 = extractvalue { i64, i1 } %4, 1 %5 = call i1 @llvm.expect.i1(i1 %_11.1, i1 false) br i1 %5, label %panic1, label %bb5 bb5: ; preds = %bb4 %_8 = call i64 @_ZN3fib3fib17h03330887093d3356E(i64 %_11.0) br label %bb6 panic1: ; preds = %bb4 call void @_ZN4core9panicking5panic17h2c89bafc52ad2c2fE([0 x i8]* nonnull align 1 bitcast ([33 x i8]* @str.1 to [0 x i8]*), i64 33, %\"std::panic::Location\"* align 8 dereferenceable(24) bitcast (<{ i8*, [16 x i8] }>* @alloc40 to %\"std::panic::Location\"*)) unreachable bb6: ; preds = %bb5 %6 = call { i64, i1 } @llvm.sadd.with.overflow.i64(i64 %_4, i64 %_8) %_12.0 = extractvalue { i64, i1 } %6, 0 %_12.1 = extractvalue { i64, i1 } %6, 1 %7 = call i1 @llvm.expect.i1(i1 %_12.1, i1 false) br i1 %7, label %panic2, label %bb7 bb7: ; preds = %bb6 store i64 %_12.0, i64* %0, align 8 br label %bb8 panic2: ; preds = %bb6 call void @_ZN4core9panicking5panic17h2c89bafc52ad2c2fE([0 x i8]* nonnull align 1 bitcast ([28 x i8]* @str.2 to [0 x i8]*), i64 28, %\"std::panic::Location\"* align 8 dereferenceable(24) bitcast (<{ i8*, [16 x i8] }>* @alloc42 to %\"std::panic::Location\"*)) unreachable } define hidden swiftcc i64 @\"$s3fibAAyS2iF\"(i64 %0) #0 { entry: + call void @_spoor_runtime_LogFunctionEntry(i64 -5425404140006146047) %n.debug = alloca i64, align 8 %1 = bitcast i64* %n.debug to i8* call void @llvm.memset.p0i8.i64(i8* align 8 %1, i8 0, i64 8, i1 false) store i64 %0, i64* %n.debug, align 8 %2 = icmp slt i64 %0, 2 br i1 %2, label %3, label %4 3: ; preds = %entry br label %22 4: ; preds = %entry %5 = call { i64, i1 } @llvm.ssub.with.overflow.i64(i64 %0, i64 1) %6 = extractvalue { i64, i1 } %5, 0 %7 = extractvalue { i64, i1 } %5, 1 %8 = call i1 @llvm.expect.i1(i1 %7, i1 false) br i1 %8, label %24, label %9 9: ; preds = %4 %10 = call swiftcc i64 @\"$s3fibAAyS2iF\"(i64 %6) %11 = call { i64, i1 } @llvm.ssub.with.overflow.i64(i64 %0, i64 2) %12 = extractvalue { i64, i1 } %11, 0 %13 = extractvalue { i64, i1 } %11, 1 %14 = call i1 @llvm.expect.i1(i1 %13, i1 false) br i1 %14, label %25, label %15 15: ; preds = %9 %16 = call swiftcc i64 @\"$s3fibAAyS2iF\"(i64 %12) %17 = call { i64, i1 } @llvm.sadd.with.overflow.i64(i64 %10, i64 %16) %18 = extractvalue { i64, i1 } %17, 0 %19 = extractvalue { i64, i1 } %17, 1 %20 = call i1 @llvm.expect.i1(i1 %19, i1 false) br i1 %20, label %26, label %21 21: ; preds = %15 br label %22 22: ; preds = %21, %3 %23 = phi i64 [ %18, %21 ], [ %0, %3 ] + call void @_spoor_runtime_LogFunctionExit(i64 -5425404140006146047) ret i64 %23 24: ; preds = %4 call void @llvm.trap() unreachable 25: ; preds = %9 call void @llvm.trap() unreachable 26: ; preds = %15 call void @llvm.trap() unreachable } Additionally, Spoor automatically initializes and enables the runtime in main . This behavior is configurable . C++ Rust Swift ; fib_instrumented.ll define dso_local i32 @main() #1 { + call void @_spoor_runtime_Initialize() + call void @_spoor_runtime_Enable() + call void @_spoor_runtime_LogFunctionEntry(i64 6838069263626928129) %1 = alloca i32, align 4 %2 = alloca i32, align 4 store i32 10, i32* %1, align 4 %3 = call i32 @_Z3Fibi(i32 10) store i32 %3, i32* %2, align 4 %4 = load i32, i32* %2, align 4 %5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str, i64 0, i64 0), i32 10, i32 %4) + call void @_spoor_runtime_LogFunctionExit(i64 6838069263626928129) + call void @_spoor_runtime_Deinitialize() ret i32 0 } ; fib_instrumented.ll define i32 @main(i32 %0, i8** %1) unnamed_addr #9 { + call void @_spoor_runtime_Initialize() + call void @_spoor_runtime_Enable() + call void @_spoor_runtime_LogFunctionEntry(i64 1161011135638405138) %2 = sext i32 %0 to i64 %3 = call i64 @_ZN3std2rt10lang_start17h11fbc72de187ccfcE(void ()* @_ZN3fib4main17h169520592592741fE, i64 %2, i8** %1) %4 = trunc i64 %3 to i32 + call void @_spoor_runtime_LogFunctionExit(i64 1161011135638405138) + call void @_spoor_runtime_Deinitialize() ret i32 %4 } ; fib_instrumented.ll define i32 @main(i32 %0, i8** %1) #0 { entry: + call void @_spoor_runtime_Initialize() + call void @_spoor_runtime_Enable() + call void @_spoor_runtime_LogFunctionEntry(i64 -5425404140006146048) %2 = alloca %Ts26DefaultStringInterpolationV, align 8 %3 = bitcast %Ts26DefaultStringInterpolationV* %2 to i8* call void @llvm.memset.p0i8.i64(i8* align 8 %3, i8 0, i64 16, i1 false) %4 = alloca %TSi, align 8 %5 = alloca %TSi, align 8 %6 = bitcast i8** %1 to i8* store i64 10, i64* getelementptr inbounds (%TSi, %TSi* @\"$s3fib1nSivp\", i32 0, i32 0), align 8 %7 = load i64, i64* getelementptr inbounds (%TSi, %TSi* @\"$s3fib1nSivp\", i32 0, i32 0), align 8 %8 = call swiftcc i64 @\"$s3fibAAyS2iF\"(i64 %7) store i64 %8, i64* getelementptr inbounds (%TSi, %TSi* @\"$s3fib1fSivp\", i32 0, i32 0), align 8 %9 = call swiftcc { %swift.bridge*, i8* } @\"$ss27_allocateUninitializedArrayySayxG_BptBwlF\"(i64 1, %swift.type* getelementptr inbounds (%swift.full_type, %swift.full_type* @\"$sypN\", i32 0, i32 1)) %10 = extractvalue { %swift.bridge*, i8* } %9, 0 %11 = extractvalue { %swift.bridge*, i8* } %9, 1 %12 = bitcast i8* %11 to %Any* %13 = bitcast %Ts26DefaultStringInterpolationV* %2 to i8* call void @llvm.lifetime.start.p0i8(i64 16, i8* %13) %14 = call swiftcc { i64, %swift.bridge* } @\"$ss26DefaultStringInterpolationV15literalCapacity18interpolationCountABSi_SitcfC\"(i64 8, i64 2) %15 = extractvalue { i64, %swift.bridge* } %14, 0 %16 = extractvalue { i64, %swift.bridge* } %14, 1 %._storage = getelementptr inbounds %Ts26DefaultStringInterpolationV, %Ts26DefaultStringInterpolationV* %2, i32 0, i32 0 %._storage._guts = getelementptr inbounds %TSS, %TSS* %._storage, i32 0, i32 0 %._storage._guts._object = getelementptr inbounds %Ts11_StringGutsV, %Ts11_StringGutsV* %._storage._guts, i32 0, i32 0 %._storage._guts._object._countAndFlagsBits = getelementptr inbounds %Ts13_StringObjectV, %Ts13_StringObjectV* %._storage._guts._object, i32 0, i32 0 %._storage._guts._object._countAndFlagsBits._value = getelementptr inbounds %Ts6UInt64V, %Ts6UInt64V* %._storage._guts._object._countAndFlagsBits, i32 0, i32 0 store i64 %15, i64* %._storage._guts._object._countAndFlagsBits._value, align 8 %._storage._guts._object._object = getelementptr inbounds %Ts13_StringObjectV, %Ts13_StringObjectV* %._storage._guts._object, i32 0, i32 1 store %swift.bridge* %16, %swift.bridge** %._storage._guts._object._object, align 8 %17 = call swiftcc { i64, %swift.bridge* } @\"$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC\"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @0, i64 0, i64 0), i64 4, i1 true) %18 = extractvalue { i64, %swift.bridge* } %17, 0 %19 = extractvalue { i64, %swift.bridge* } %17, 1 call swiftcc void @\"$ss26DefaultStringInterpolationV13appendLiteralyySSF\"(i64 %18, %swift.bridge* %19, %Ts26DefaultStringInterpolationV* nocapture swiftself dereferenceable(16) %2) call void @swift_bridgeObjectRelease(%swift.bridge* %19) #3 %20 = load i64, i64* getelementptr inbounds (%TSi, %TSi* @\"$s3fib1nSivp\", i32 0, i32 0), align 8 %21 = bitcast %TSi* %4 to i8* call void @llvm.lifetime.start.p0i8(i64 8, i8* %21) %._value = getelementptr inbounds %TSi, %TSi* %4, i32 0, i32 0 store i64 %20, i64* %._value, align 8 %22 = bitcast %TSi* %4 to %swift.opaque* call swiftcc void @\"$ss26DefaultStringInterpolationV06appendC0yyxs06CustomB11ConvertibleRzlF\"(%swift.opaque* noalias nocapture %22, %swift.type* @\"$sSiN\", i8** @\"$sSis23CustomStringConvertiblesWP\", %Ts26DefaultStringInterpolationV* nocapture swiftself dereferenceable(16) %2) %23 = bitcast %TSi* %4 to i8* call void @llvm.lifetime.end.p0i8(i64 8, i8* %23) %24 = call swiftcc { i64, %swift.bridge* } @\"$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC\"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @1, i64 0, i64 0), i64 4, i1 true) %25 = extractvalue { i64, %swift.bridge* } %24, 0 %26 = extractvalue { i64, %swift.bridge* } %24, 1 call swiftcc void @\"$ss26DefaultStringInterpolationV13appendLiteralyySSF\"(i64 %25, %swift.bridge* %26, %Ts26DefaultStringInterpolationV* nocapture swiftself dereferenceable(16) %2) call void @swift_bridgeObjectRelease(%swift.bridge* %26) #3 %27 = load i64, i64* getelementptr inbounds (%TSi, %TSi* @\"$s3fib1fSivp\", i32 0, i32 0), align 8 %28 = bitcast %TSi* %5 to i8* call void @llvm.lifetime.start.p0i8(i64 8, i8* %28) %._value1 = getelementptr inbounds %TSi, %TSi* %5, i32 0, i32 0 store i64 %27, i64* %._value1, align 8 %29 = bitcast %TSi* %5 to %swift.opaque* call swiftcc void @\"$ss26DefaultStringInterpolationV06appendC0yyxs06CustomB11ConvertibleRzlF\"(%swift.opaque* noalias nocapture %29, %swift.type* @\"$sSiN\", i8** @\"$sSis23CustomStringConvertiblesWP\", %Ts26DefaultStringInterpolationV* nocapture swiftself dereferenceable(16) %2) %30 = bitcast %TSi* %5 to i8* call void @llvm.lifetime.end.p0i8(i64 8, i8* %30) %31 = call swiftcc { i64, %swift.bridge* } @\"$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC\"(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @2, i64 0, i64 0), i64 0, i1 true) %32 = extractvalue { i64, %swift.bridge* } %31, 0 %33 = extractvalue { i64, %swift.bridge* } %31, 1 call swiftcc void @\"$ss26DefaultStringInterpolationV13appendLiteralyySSF\"(i64 %32, %swift.bridge* %33, %Ts26DefaultStringInterpolationV* nocapture swiftself dereferenceable(16) %2) call void @swift_bridgeObjectRelease(%swift.bridge* %33) #3 %._storage2 = getelementptr inbounds %Ts26DefaultStringInterpolationV, %Ts26DefaultStringInterpolationV* %2, i32 0, i32 0 %._storage2._guts = getelementptr inbounds %TSS, %TSS* %._storage2, i32 0, i32 0 %._storage2._guts._object = getelementptr inbounds %Ts11_StringGutsV, %Ts11_StringGutsV* %._storage2._guts, i32 0, i32 0 %._storage2._guts._object._countAndFlagsBits = getelementptr inbounds %Ts13_StringObjectV, %Ts13_StringObjectV* %._storage2._guts._object, i32 0, i32 0 %._storage2._guts._object._countAndFlagsBits._value = getelementptr inbounds %Ts6UInt64V, %Ts6UInt64V* %._storage2._guts._object._countAndFlagsBits, i32 0, i32 0 %34 = load i64, i64* %._storage2._guts._object._countAndFlagsBits._value, align 8 %._storage2._guts._object._object = getelementptr inbounds %Ts13_StringObjectV, %Ts13_StringObjectV* %._storage2._guts._object, i32 0, i32 1 %35 = load %swift.bridge*, %swift.bridge** %._storage2._guts._object._object, align 8 %36 = call %swift.bridge* @swift_bridgeObjectRetain(%swift.bridge* returned %35) #3 %37 = call %Ts26DefaultStringInterpolationV* @\"$ss26DefaultStringInterpolationVWOh\"(%Ts26DefaultStringInterpolationV* %2) %38 = bitcast %Ts26DefaultStringInterpolationV* %2 to i8* call void @llvm.lifetime.end.p0i8(i64 16, i8* %38) %39 = call swiftcc { i64, %swift.bridge* } @\"$sSS19stringInterpolationSSs013DefaultStringB0V_tcfC\"(i64 %34, %swift.bridge* %35) %40 = extractvalue { i64, %swift.bridge* } %39, 0 %41 = extractvalue { i64, %swift.bridge* } %39, 1 %42 = getelementptr inbounds %Any, %Any* %12, i32 0, i32 1 store %swift.type* @\"$sSSN\", %swift.type** %42, align 8 %43 = getelementptr inbounds %Any, %Any* %12, i32 0, i32 0 %44 = getelementptr inbounds %Any, %Any* %12, i32 0, i32 0 %45 = bitcast [24 x i8]* %44 to %TSS* %._guts = getelementptr inbounds %TSS, %TSS* %45, i32 0, i32 0 %._guts._object = getelementptr inbounds %Ts11_StringGutsV, %Ts11_StringGutsV* %._guts, i32 0, i32 0 %._guts._object._countAndFlagsBits = getelementptr inbounds %Ts13_StringObjectV, %Ts13_StringObjectV* %._guts._object, i32 0, i32 0 %._guts._object._countAndFlagsBits._value = getelementptr inbounds %Ts6UInt64V, %Ts6UInt64V* %._guts._object._countAndFlagsBits, i32 0, i32 0 store i64 %40, i64* %._guts._object._countAndFlagsBits._value, align 8 %._guts._object._object = getelementptr inbounds %Ts13_StringObjectV, %Ts13_StringObjectV* %._guts._object, i32 0, i32 1 store %swift.bridge* %41, %swift.bridge** %._guts._object._object, align 8 %46 = call swiftcc %swift.bridge* @\"$ss27_finalizeUninitializedArrayySayxGABnlF\"(%swift.bridge* %10, %swift.type* getelementptr inbounds (%swift.full_type, %swift.full_type* @\"$sypN\", i32 0, i32 1)) %47 = call swiftcc { i64, %swift.bridge* } @\"$ss5print_9separator10terminatoryypd_S2StFfA0_\"() %48 = extractvalue { i64, %swift.bridge* } %47, 0 %49 = extractvalue { i64, %swift.bridge* } %47, 1 %50 = call swiftcc { i64, %swift.bridge* } @\"$ss5print_9separator10terminatoryypd_S2StFfA1_\"() %51 = extractvalue { i64, %swift.bridge* } %50, 0 %52 = extractvalue { i64, %swift.bridge* } %50, 1 call swiftcc void @\"$ss5print_9separator10terminatoryypd_S2StF\"(%swift.bridge* %46, i64 %48, %swift.bridge* %49, i64 %51, %swift.bridge* %52) call void @swift_bridgeObjectRelease(%swift.bridge* %52) #3 call void @swift_bridgeObjectRelease(%swift.bridge* %49) #3 call void @swift_bridgeObjectRelease(%swift.bridge* %46) #3 + call void @_spoor_runtime_LogFunctionExit(i64 -5425404140006146048) + call void @_spoor_runtime_Deinitialize() ret i32 0 } Each call to LogFunctionEntry and LogFunctionExit contains a single numeric argument. This number uniquely identifies the function in your program and is logged in the trace at runtime. fib.spoor_symbols maps these numbers to debug data to symbolize the trace offline. The easiest way to inspect the symbols file is by converting it to a csv . spoor fib.spoor_symbols --output_file = fib_symbols.csv C++ Rust Swift Function ID Linkage name Demangled name 0x5ee5b3c400000000 _Z3Fibi Fib(int) 0x5ee5b3c400000001 main main Function ID Linkage name Demangled name 0x101cbd7a00001300 _ZN3fib3fib17h03330887093d3356E fib::fib::h03330887093d3356 0x101cbd7a00001300 _zn3fib4main17h169520592592741fE fib::main::h169520592592741f 0x101cbd7a00001300 main main Function ID Linkage name Demangled name 0xb4b517ae00000000 main main 0xb4b517ae00000001 $s3fibAAyS2iF fib.fib(Swift.Int) -> Swift.Int","title":"1.2 Inject instrumentation"},{"location":"tutorials/fibonacci/#2-compile-and-run","text":"","title":"2. Compile and run"},{"location":"tutorials/fibonacci/#21-compile-the-ir","text":"Compile the instrumented IR using clang++ and link in the runtime library. The runtime library is responsible for efficiently handling incoming instrumentation events (e.g., function entries and exists) by buffering them in-memory and flushing them to disk. C++ Rust Swift clang++ \\ fib_instrumented.ll \\ -o fib_instrumented \\ -L/path/to/spoor/libraries \\ -lspoor_runtime \\ -lspoor_runtime_default_config clang++ \\ fib_instrumented.ll \\ -o fib_instrumented \\ -L/path/to/spoor/libraries \\ -lspoor_runtime \\ -lspoor_runtime_default_config \\ -L/path/to/.rustup/toolchains/stable-target/lib \\ -lstd-xxxxxxxxxxxxxxxx \\ -Wl,-rpath,/path/to/.rustup/toolchains/stable-target/lib clang++ \\ fib_instrumented.ll \\ -o fib_instrumented \\ -L/path/to/libspoor_runtime \\ -lspoor_runtime \\ -lspoor_runtime_default_config \\ -L/usr/lib/swift","title":"2.1 Compile the IR"},{"location":"tutorials/fibonacci/#22-run-the-instrumented-binary","text":"Run the instrumented binary. ./fib_instrumented Your program prints the tenth Fibonacci number to stdout as before. Fib(10) = 55 Additionally, your program emits one or more binary .spoor_trace files which efficiently store the trace data for that execution. By default, Spoor's runtime saves trace files in the current directory. find . -name \"*.spoor_trace\" xxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx.spoor_trace","title":"2.2 Run the instrumented binary"},{"location":"tutorials/fibonacci/#3-process-and-analyze-the-trace","text":"Finally, parse and symbolize the trace data to view it in Perfetto's trace viewer .","title":"3. Process and analyze the trace"},{"location":"tutorials/fibonacci/#31-parse-and-symbolize-the-trace","text":"Use spoor , Spoor's postprocessing tool, to parse the .spoor_trace file(s), symbolize the trace with the .spoor_symbols file(s), and output a Perfetto-compatible trace. spoor \\ xxxxxxxxxxxxxxxx-yyyyyyyyyyyyyyyy-zzzzzzzzzzzzzzzz.spoor_trace \\ fib.spoor_symbols \\ --output_file = fib.perfetto","title":"3.1 Parse and symbolize the trace"},{"location":"tutorials/fibonacci/#32-visualize-the-trace","text":"Open fib.perfetto in ui.perfetto.dev , Perfetto's trace viewer. The flame graph timeline visualization shows the stack trace of your program over time. Notice the tree-like structure formed by the exponential calls. C++ Rust Swift","title":"3.2 Visualize the trace"},{"location":"tutorials/fibonacci/#33-query-the-trace","text":"Perfetto's supports querying the trace with SQL. What data does the slice table contain? SELECT * FROM slice ; id type ts dur track_id category name depth stack_id parent_stack_id parent_id arg_set_id cat slice_id 0 thread_slice 1634680417099962600 264152 0 NULL main 0 6833849221975760 0 NULL 2 NULL 1 thread_slice 1634680417100002800 194521 0 NULL Fib(int) 1 1089519434040343 6833849221975760 0 3 NULL 1 2 thread_slice 1634680417100003600 130467 0 NULL Fib(int) 2 1009479496053168 1089519434040343 1 3 NULL 2 How many times was Fib called? SELECT COUNT ( * ) FROM slice WHERE name LIKE 'fib%' ; 177 What's the deepest stack? SELECT MAX ( depth ) FROM slice WHERE name LIKE 'fib%' ; 10","title":"3.3 Query the trace"},{"location":"tutorials/fibonacci/#going-further","text":"The time complexity of this Fibonacci implementation is exponential \u2013 a suboptimal algorithm. Optimize the runtime of your Fibonacci program by caching already-computed values (i.e., dynamic programming), instrument your new code, and visualize the trace with Perfetto. Closed-form solution There's an even more optimal, closed-form, constant-time solution, but a single function call doesn't look very interesting in the trace. \\[ F_n = \\frac{\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n - \\left(\\frac{1 - \\sqrt{5}}{2}\\right)^n}{\\sqrt{5}} \\]","title":"Going further"},{"location":"tutorials/fibonacci/#optimize-the-code","text":"C++ Rust Swift // fib.cc #include <cstdio> #include <unordered_map> auto Fib ( const int n , std :: unordered_map < int , int >* cache ) -> int { if ( n < 2 ) return n ; if ( cache -> find ( n ) != cache -> cend ()) return cache -> at ( n ); const auto result = Fib ( n - 1 , cache ) + Fib ( n - 2 , cache ); cache -> emplace ( n , result ); return result ; } auto main () -> int { constexpr auto n = 10 ; std :: unordered_map < int , int > cache {}; const auto f = Fib ( n , & cache ); printf ( \"Fib(%d) = %d \\n \" , n , f ); } // fib.rs use std :: collections :: HashMap ; fn fib ( n : i64 , cache : & mut HashMap < i64 , i64 > ) -> i64 { if n < 2 { return n ; } if let Some ( result ) = cache . get ( & n ) { return * result } let result = fib ( n - 1 , cache ) + fib ( n - 2 , cache ); cache . insert ( n , result ); return result } pub fn main () { let n = 10 ; let mut cache = HashMap :: new (); let f = fib ( n , & mut cache ); println! ( \"Fib({}) = {}\" , n , f ); } // fib.swift import Foundation func fib ( _ n : Int , _ cache : inout [ Int : Int ]) -> Int { if n < 2 { return n } if let result = cache [ n ] { return result } let result = fib ( n - 1 , & cache ) + fib ( n - 2 , & cache ) cache [ n ] = result return result } let n = 10 var cache = [ Int : Int ]() let f = fib ( n , & cache ) print ( \"Fib( \\( n ) ) = \\( f ) \" )","title":"Optimize the code"},{"location":"tutorials/fibonacci/#visualize-the-optimized-code","text":"C++ Rust Swift By default, Spoor instruments all source code it compiles from source. This includes C++'s (header-only) standard template library but not Swift's (precompiled) Foundations library. Therefore, calls to C++'s std::unordered_map appear in the trace but calls to Swift's Dictionary do not. Filters file Filter unwanted functions from the trace by configuring spoor_opt with a filters file .","title":"Visualize the optimized code"},{"location":"tutorials/fibonacci/#query-the-optimized-code","text":"How many times was Fib called? SELECT COUNT ( * ) FROM slice WHERE name LIKE 'fib%' ; 19 Recall that original implementation (without caching) made 177 function calls to Fib \u2013 strong evidence that caching reduced unnecessary recursive calls. What's the deepest stack? SELECT MAX ( depth ) FROM slice WHERE name LIKE 'fib%' ; 10","title":"Query the optimized code"},{"location":"tutorials/fibonacci/#conclusion","text":"Spoor is a toolchain to instrumented source code, efficiently handle incoming events, and parse the generated trace files for offline analysis using tools such as Perfetto's visualizer.","title":"Conclusion"},{"location":"tutorials/wikipedia-ios/","text":"Wikipedia iOS This tutorial uses Spoor to instrument Wikipedia's iOS app . You'll learn Spoor's pipeline to automatically inject instrumentation into your source code, build and run your Spoor-instrumented program, symbolize the trace, and visualize and analyze your symbolized trace using Perfetto. 0. Prerequisites 0.1 Setup and dependencies MicrosoftSpoor.xctoolchain : Spoor's Xcode toolchain spoor : Postprocessing tool Xcode Version This tutorial uses the following tools. Your mileage may vary with newer or older versions. MicrosoftSpoor.xctoolchain 0.0.0 Xcode xcodebuild -version Xcode 13.3 Build version 13E113 spoor spoor --version spoor 0.0.0 0.2 Download the code Git (SSH) Git (HTTPS) cURL git clone \\ --branch releases/6.8.2 \\ --depth 1 \\ git@github.com:wikimedia/wikipedia-ios.git git clone \\ --branch releases/6.8.2 \\ --depth 1 \\ https://github.com/wikimedia/wikipedia-ios.git curl \\ --location \\ --output wikipedia-ios.tar.gz \\ https://github.com/wikimedia/wikipedia-ios/archive/refs/tags/releases/6.8.2.tar.gz && tar -xf wikipedia-ios.tar.gz && mv wikipedia-ios-releases-6.8.2 wikipedia-ios cd wikipedia-ios Version This tutorial is based on Wikipedia iOS version 6.8.2. Your mileage may vary with newer or older versions. Sanity test Build and run the (uninstrumented) app to make sure that everything works as expected. A clean build takes around four minutes (depending on how baller your computer is). UI Command line open Wikipedia.xcodeproj Build and run: Product > Run (\u2318R) . xcodebuild build \\ -project Wikipedia.xcodeproj \\ -scheme Wikipedia \\ -configuration Debug \\ -sdk iphonesimulator \\ -arch x86_64 open -a Simulator.app xcrun simctl \\ install \\ booted \\ ~/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx/Build/Products/Debug-iphonesimulator/Wikipedia.app xcrun simctl launch booted org.wikimedia.wikipedia The app launches in the iOS Simulator. 1. Instrument the app UI Command line Select Spoor from Xcode's toolchains list: Xcode > Toolchains > Spoor . Build: Product > Build (\u2318B) . xcodebuild build \\ -project Wikipedia.xcodeproj \\ -scheme Wikipedia \\ -configuration Debug \\ -sdk iphonesimulator \\ -arch x86_64 \\ -toolchain Spoor Spoor generates a .spoor_symbols file next to each object file. find ~/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx \\ -name \"*.spoor_symbols\" /Users/you/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx/Build/Intermediates.noindex/Wikipedia.build/Debug-iphonesimulator/WMF.build/Objects-normal/x86_64/NavigationState.spoor_symbols /Users/you/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx/Build/Intermediates.noindex/Wikipedia.build/Debug-iphonesimulator/WMF.build/Objects-normal/x86_64/NSDate+WMFRelativeDate.spoor_symbols /Users/you/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx/Build/Intermediates.noindex/Wikipedia.build/Debug-iphonesimulator/WMF.build/Objects-normal/x86_64/CIContext+WMFImageProcessing.spoor_symbols /Users/you/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx/Build/Intermediates.noindex/Wikipedia.build/Debug-iphonesimulator/WMF.build/Objects-normal/x86_64/NSError+WMFExtensions.spoor_symbols /Users/you/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx/Build/Intermediates.noindex/Wikipedia.build/Debug-iphonesimulator/WMF.build/Objects-normal/x86_64/CacheGroup+CoreDataProperties.spoor_symbols ... 2. Run with instrumentation Create a directory to hold the trace files and configure Spoor's runtime to save the traces in that path. mkdir trace UI Command line Configure Wikipedia's scheme with a run action environment variable that sets the trace file output path: Wikipedia > Edit Scheme.. . Key Value SPOOR_RUNTIME_TRACE_FILE_PATH /path/to/trace/ Run: Product > Run (\u2318R) . Appling environment variables Environment variables are only applied when launching the app from Xcode (i.e., not when tapping the app's icon on the homescreen). Install the instrumented build. xcrun simctl \\ install \\ booted \\ ~/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx/Build/Products/Debug-iphonesimulator/Wikipedia.app Launch the app with a SPOOR_RUNTIME_TRACE_FILE_PATH environment variable configuration. SIMCTL_CHILD_SPOOR_RUNTIME_TRACE_FILE_PATH = \"/path/to/trace/\" xcrun simctl \\ launch \\ booted \\ org.wikimedia.wikipedia Spoor's runtime emits trace files in the trace folder configured above. ls trace xxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx.spoor_trace ... 3. Process and analyze the trace Finally, parse and symbolize the trace data to view it in Perfetto's trace viewer . 3.1 Parse and symbolize the trace Use spoor , Spoor's postprocessing tool, to parse the .spoor_trace files in your trace folder, symbolize the trace with the spoor_symbols files in DerivedData , and output a Perfetto-compatible trace. spoor \\ /path/to/trace/ \\ ~/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx \\ --output_file = wikipedia-ios.perfetto 3.2 Visualize the trace Open wikipedia-ios.perfetto in ui.perfetto.dev , Perfetto's trace viewer. The flame graph timeline visualization shows the stack trace of the app's boot over time.","title":"Wikipedia iOS"},{"location":"tutorials/wikipedia-ios/#wikipedia-ios","text":"This tutorial uses Spoor to instrument Wikipedia's iOS app . You'll learn Spoor's pipeline to automatically inject instrumentation into your source code, build and run your Spoor-instrumented program, symbolize the trace, and visualize and analyze your symbolized trace using Perfetto.","title":"Wikipedia iOS"},{"location":"tutorials/wikipedia-ios/#0-prerequisites","text":"","title":"0. Prerequisites"},{"location":"tutorials/wikipedia-ios/#01-setup-and-dependencies","text":"MicrosoftSpoor.xctoolchain : Spoor's Xcode toolchain spoor : Postprocessing tool Xcode Version This tutorial uses the following tools. Your mileage may vary with newer or older versions. MicrosoftSpoor.xctoolchain 0.0.0 Xcode xcodebuild -version Xcode 13.3 Build version 13E113 spoor spoor --version spoor 0.0.0","title":"0.1 Setup and dependencies"},{"location":"tutorials/wikipedia-ios/#02-download-the-code","text":"Git (SSH) Git (HTTPS) cURL git clone \\ --branch releases/6.8.2 \\ --depth 1 \\ git@github.com:wikimedia/wikipedia-ios.git git clone \\ --branch releases/6.8.2 \\ --depth 1 \\ https://github.com/wikimedia/wikipedia-ios.git curl \\ --location \\ --output wikipedia-ios.tar.gz \\ https://github.com/wikimedia/wikipedia-ios/archive/refs/tags/releases/6.8.2.tar.gz && tar -xf wikipedia-ios.tar.gz && mv wikipedia-ios-releases-6.8.2 wikipedia-ios cd wikipedia-ios Version This tutorial is based on Wikipedia iOS version 6.8.2. Your mileage may vary with newer or older versions. Sanity test Build and run the (uninstrumented) app to make sure that everything works as expected. A clean build takes around four minutes (depending on how baller your computer is). UI Command line open Wikipedia.xcodeproj Build and run: Product > Run (\u2318R) . xcodebuild build \\ -project Wikipedia.xcodeproj \\ -scheme Wikipedia \\ -configuration Debug \\ -sdk iphonesimulator \\ -arch x86_64 open -a Simulator.app xcrun simctl \\ install \\ booted \\ ~/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx/Build/Products/Debug-iphonesimulator/Wikipedia.app xcrun simctl launch booted org.wikimedia.wikipedia The app launches in the iOS Simulator.","title":"0.2 Download the code"},{"location":"tutorials/wikipedia-ios/#1-instrument-the-app","text":"UI Command line Select Spoor from Xcode's toolchains list: Xcode > Toolchains > Spoor . Build: Product > Build (\u2318B) . xcodebuild build \\ -project Wikipedia.xcodeproj \\ -scheme Wikipedia \\ -configuration Debug \\ -sdk iphonesimulator \\ -arch x86_64 \\ -toolchain Spoor Spoor generates a .spoor_symbols file next to each object file. find ~/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx \\ -name \"*.spoor_symbols\" /Users/you/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx/Build/Intermediates.noindex/Wikipedia.build/Debug-iphonesimulator/WMF.build/Objects-normal/x86_64/NavigationState.spoor_symbols /Users/you/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx/Build/Intermediates.noindex/Wikipedia.build/Debug-iphonesimulator/WMF.build/Objects-normal/x86_64/NSDate+WMFRelativeDate.spoor_symbols /Users/you/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx/Build/Intermediates.noindex/Wikipedia.build/Debug-iphonesimulator/WMF.build/Objects-normal/x86_64/CIContext+WMFImageProcessing.spoor_symbols /Users/you/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx/Build/Intermediates.noindex/Wikipedia.build/Debug-iphonesimulator/WMF.build/Objects-normal/x86_64/NSError+WMFExtensions.spoor_symbols /Users/you/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx/Build/Intermediates.noindex/Wikipedia.build/Debug-iphonesimulator/WMF.build/Objects-normal/x86_64/CacheGroup+CoreDataProperties.spoor_symbols ...","title":"1. Instrument the app"},{"location":"tutorials/wikipedia-ios/#2-run-with-instrumentation","text":"Create a directory to hold the trace files and configure Spoor's runtime to save the traces in that path. mkdir trace UI Command line Configure Wikipedia's scheme with a run action environment variable that sets the trace file output path: Wikipedia > Edit Scheme.. . Key Value SPOOR_RUNTIME_TRACE_FILE_PATH /path/to/trace/ Run: Product > Run (\u2318R) . Appling environment variables Environment variables are only applied when launching the app from Xcode (i.e., not when tapping the app's icon on the homescreen). Install the instrumented build. xcrun simctl \\ install \\ booted \\ ~/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx/Build/Products/Debug-iphonesimulator/Wikipedia.app Launch the app with a SPOOR_RUNTIME_TRACE_FILE_PATH environment variable configuration. SIMCTL_CHILD_SPOOR_RUNTIME_TRACE_FILE_PATH = \"/path/to/trace/\" xcrun simctl \\ launch \\ booted \\ org.wikimedia.wikipedia Spoor's runtime emits trace files in the trace folder configured above. ls trace xxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx.spoor_trace ...","title":"2. Run with instrumentation"},{"location":"tutorials/wikipedia-ios/#3-process-and-analyze-the-trace","text":"Finally, parse and symbolize the trace data to view it in Perfetto's trace viewer .","title":"3. Process and analyze the trace"},{"location":"tutorials/wikipedia-ios/#31-parse-and-symbolize-the-trace","text":"Use spoor , Spoor's postprocessing tool, to parse the .spoor_trace files in your trace folder, symbolize the trace with the spoor_symbols files in DerivedData , and output a Perfetto-compatible trace. spoor \\ /path/to/trace/ \\ ~/Library/Developer/Xcode/DerivedData/Wikipedia-xxxxxxxxxxxxxxxxxxxxxxxxxxxx \\ --output_file = wikipedia-ios.perfetto","title":"3.1 Parse and symbolize the trace"},{"location":"tutorials/wikipedia-ios/#32-visualize-the-trace","text":"Open wikipedia-ios.perfetto in ui.perfetto.dev , Perfetto's trace viewer. The flame graph timeline visualization shows the stack trace of the app's boot over time.","title":"3.2 Visualize the trace"}]}